# qerman language file for GNU Bash 5.0
# Copyright (C) 2019 Free Software Foundation, Inc.
# This file is distributed under the same license as the bash package.
# Roland Illig <roland.illig@gmx.de> 2019
# Nils Naumann <nau@gmx.net>, 1996-2021.
#
msgid ""
msgstr ""
"Project-Id-Version: bash 5.1\n"
"Report-Msgid-Bugs-To: jake.hamby@gmail.com\n"
"POT-Creation-Date: 2022-09-27 20:30-0700\n"
"PO-Revision-Date: 2021-12-29 22:04+0100\n"
"Last-Translator: Nils Naumann <nau@gmx.net>\n"
"Language-Team: German <translation-team-de@lists.sourceforge.net>\n"
"Language: de\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"X-Bugs: Report translation errors to the Language-Team address.\n"
"Plural-Forms: nplurals=2; plural=(n != 1)\n"

#: arrayfunc.cc:77 error.cc:347
msgid "bad array subscript"
msgstr "Falscher Feldindex."

#: arrayfunc.cc:404 builtins/declare_def.cc:661 variables.cc:2145
#: variables.cc:2169 variables.cc:2971
#, c-format
msgid "%s: removing nameref attribute"
msgstr "%s: Entferne das Nameref Attribut."

#: arrayfunc.cc:431 builtins/declare_def.cc:902
#, c-format
msgid "%s: cannot convert indexed to associative array"
msgstr ""
"%s: Das indizierte Array kann in kein assoziatives Array umgewandelt werden."

#: arrayfunc.cc:678
#, c-format
msgid "%s: invalid associative array key"
msgstr "%s: Ungültiger Schlüssel für das assoziative Array."

#: arrayfunc.cc:680
#, c-format
msgid "%s: cannot assign to non-numeric index"
msgstr "%s: Das Zuweisen auf einen nicht-numerischen Index ist nicht möglich."

#: arrayfunc.cc:727
#, c-format
msgid "%s: %s: must use subscript when assigning associative array"
msgstr ""
"%s: %s: Ein Feldindex wird zum Zuweisen eines assoziativen Arrays benötigt."

#: bashhist.cc:403
#, c-format
msgid "%s: cannot create: %s"
msgstr "%s: Kann die Datei %s nicht erzeugen."

#: bashline.cc:4425
msgid "bash_execute_unix_command: cannot find keymap for command"
msgstr ""
"bash_execute_unix_command: Kann nicht die Tastenzuordnung für das Kommando "
"finden."

#: bashline.cc:4584
#, c-format
msgid "%s: first non-whitespace character is not `\"'"
msgstr " %s: Das erste Zeichen ist nicht `\\'."

#: bashline.cc:4615
#, c-format
msgid "no closing `%c' in %s"
msgstr "fehlende schließende `%c' in %s."

#: bashline.cc:4645
#, c-format
msgid "%s: missing colon separator"
msgstr "%s: Fehlender Doppelpunkt."

#: bashline.cc:4680
#, fuzzy, c-format
msgid "`%s': cannot unbind in command keymap"
msgstr "»%s«: Bindung kann nicht gelöst werden."

#: braces.cc:307
#, c-format
msgid "brace expansion: cannot allocate memory for %s"
msgstr "Klammererweiterung: Konnte keinen Speicher für %s zuweisen."

#: braces.cc:387
#, c-format
msgid "brace expansion: failed to allocate memory for %u elements"
msgstr "Klammererweiterung: Konnte keinen Speicher für %u Elemente zuweisen."

#: braces.cc:434
#, c-format
msgid "brace expansion: failed to allocate memory for `%s'"
msgstr "Klammererweiterung: Konnte keinen Speicher für »%s« zuweisen."

#: builtins/alias_def.cc:128 variables.cc:1724
#, c-format
msgid "`%s': invalid alias name"
msgstr "»%s«: Ungültiger Aliasname."

#: builtins/bind_def.cc:125 builtins/bind_def.cc:128
msgid "line editing not enabled"
msgstr "Zeileneditierung ist nicht aktiviert."

#: builtins/bind_def.cc:216
#, c-format
msgid "`%s': invalid keymap name"
msgstr "»%s«: Ungültiger Tastenzuordnungs-Name."

#: builtins/bind_def.cc:256
#, c-format
msgid "%s: cannot read: %s"
msgstr "%s: Nicht lesbar: %s"

#: builtins/bind_def.cc:331 builtins/bind_def.cc:360
#, c-format
msgid "`%s': unknown function name"
msgstr "%s: Unbekannter Funktionsname."

#: builtins/bind_def.cc:339
#, c-format
msgid "%s is not bound to any keys.\n"
msgstr "%s ist keiner Taste zugeordnet.\n"

#: builtins/bind_def.cc:343
#, c-format
msgid "%s can be invoked via "
msgstr "%s kann aufgerufen werden durch "

#: builtins/bind_def.cc:379 builtins/bind_def.cc:396
#, c-format
msgid "`%s': cannot unbind"
msgstr "»%s«: Bindung kann nicht gelöst werden."

#: builtins/break_def.cc:76 builtins/break_def.cc:117
msgid "loop count"
msgstr "Schleifenzähler"

#: builtins/break_def.cc:137
msgid "only meaningful in a `for', `while', or `until' loop"
msgstr "nur in einer for-, while- oder until-Schleife sinnvoll."

# caller
#: builtins/caller_def.cc:133
msgid ""
"Returns the context of the current subroutine call.\n"
"    \n"
"    Without EXPR, returns \"$line $filename\".  With EXPR, returns\n"
"    \"$line $subroutine $filename\"; this extra information can be used to\n"
"    provide a stack trace.\n"
"    \n"
"    The value of EXPR indicates how many call frames to go back before the\n"
"    current one; the top frame is frame 0."
msgstr ""
"Gibt Informationen zum aktuellen Subroutinenaufruf aus.\n"
"\n"
"    Ohne Argument wird die Zeilennummer und der Dateiname angezeigt. Mit\n"
"    Argument werden Zeilennummer, Subroutinenname und Dateiname ausgegeben.\n"
"    Mit diesen Informationen kann ein Stacktrace erzeugt werden.\n"
"\n"
"    Das Argument gibt die angezeigte Position im Funktionsaufrufstapel an,\n"
"    wobei 0 der aktuelle Funktionsaufruf ist."

#: builtins/cd_def.cc:317
msgid "HOME not set"
msgstr "HOME ist nicht zugewiesen."

#: builtins/cd_def.cc:325 builtins/common.cc:133 test.cc:918
msgid "too many arguments"
msgstr "Zu viele Argumente."

#: builtins/cd_def.cc:332
msgid "null directory"
msgstr "NULL Verzeichnis"

#: builtins/cd_def.cc:343
msgid "OLDPWD not set"
msgstr "OLDPWD ist nicht zugewiesen."

# Debug Ausgabe
#: builtins/common.cc:81
#, c-format
msgid "line %d: "
msgstr "Zeile %d: "

#: builtins/common.cc:107 error.cc:198
#, c-format
msgid "warning: "
msgstr "Warnung: "

#: builtins/common.cc:121
#, c-format
msgid "%s: usage: "
msgstr "%s: Aufruf: "

#: builtins/common.cc:163 shell.cc:354 shell.cc:678
#, c-format
msgid "%s: option requires an argument"
msgstr "%s: Die Option erfordert ein Argument."

#: builtins/common.cc:169
#, c-format
msgid "%s: numeric argument required"
msgstr "%s: Ein numerischer Parameter ist erforderlich."

#: builtins/common.cc:175
#, c-format
msgid "%s: not found"
msgstr "%s: Nicht gefunden."

#: builtins/common.cc:183 shell.cc:692
#, c-format
msgid "%s: invalid option"
msgstr "%s: Ungültige Option."

#: builtins/common.cc:189
#, c-format
msgid "%s: invalid option name"
msgstr "%s: Ungültiger Optionsname."

#: builtins/common.cc:195 execute_cmd.cc:2265 general.cc:402 general.cc:409
#, c-format
msgid "`%s': not a valid identifier"
msgstr "»%s«: Ist kein gültiger Bezeichner."

#: builtins/common.cc:204
msgid "invalid octal number"
msgstr "Ungültige Oktalzahl."

#: builtins/common.cc:206
msgid "invalid hex number"
msgstr "Ungültige hexadezimale Zahl."

#: builtins/common.cc:208 expr.cc:1333
msgid "invalid number"
msgstr "Ungültige Zahl."

#: builtins/common.cc:215
#, c-format
msgid "%s: invalid signal specification"
msgstr "%s: Ungültige Signalbezeichnung."

#: builtins/common.cc:221
#, c-format
msgid "`%s': not a pid or valid job spec"
msgstr "»%s«: Ist keine gültige Prozess-ID oder Jobbezeichnung."

#: builtins/common.cc:227 error.cc:360
#, c-format
msgid "%s: readonly variable"
msgstr "%s: Schreibgeschützte Variable."

#: builtins/common.cc:234
#, c-format
msgid "%s: %s out of range"
msgstr "%s: %s ist außerhalb des Gültigkeitsbereiches."

#: builtins/common.cc:234 builtins/common.cc:236
msgid "argument"
msgstr "Argument"

#: builtins/common.cc:236
#, c-format
msgid "%s out of range"
msgstr "%s ist außerhalb des Gültigkeitsbereiches."

#: builtins/common.cc:243
#, c-format
msgid "%s: no such job"
msgstr "%s: Kein solcher Job."

#: builtins/common.cc:250
#, c-format
msgid "%s: no job control"
msgstr "%s: Keine Jobsteuerung in dieser Shell."

#: builtins/common.cc:252
msgid "no job control"
msgstr "Keine Jobsteuerung in dieser Shell."

#: builtins/common.cc:261
#, c-format
msgid "%s: restricted"
msgstr "%s: eingeschränkt"

#: builtins/common.cc:263
msgid "restricted"
msgstr "eingeschränkt"

#: builtins/common.cc:270
#, c-format
msgid "%s: not a shell builtin"
msgstr "%s: Ist kein eingebautes Shellkommando."

#: builtins/common.cc:279
#, c-format
msgid "write error: %s"
msgstr "Schreibfehler: %s."

#: builtins/common.cc:286
#, c-format
msgid "error setting terminal attributes: %s"
msgstr "Fehler beim Setzen der Terminalattribute: %s"

#: builtins/common.cc:289
#, c-format
msgid "error getting terminal attributes: %s"
msgstr "Fehler beim Ermitteln der Terminalattribute: %s"

#: builtins/common.cc:578
#, c-format
msgid "%s: error retrieving current directory: %s: %s\n"
msgstr "%s: Kann das aktuelle Verzeichnis nicht wiederfinden: %s: %s\n"

#: builtins/common.cc:638 builtins/common.cc:640
#, c-format
msgid "%s: ambiguous job spec"
msgstr "%s: Mehrdeutige Jobbezeichnung."

#: builtins/common.cc:892
msgid "help not available in this version"
msgstr "In dieser Version ist keine Hilfe verfügbar."

#: builtins/common.cc:935 builtins/set_def.cc:912 variables.cc:3667
#, c-format
msgid "%s: cannot unset: readonly %s"
msgstr "%s: »unset« nicht möglich: %s ist schreibgeschützt"

#: builtins/common.cc:940 builtins/set_def.cc:889 variables.cc:3672
#, c-format
msgid "%s: cannot unset"
msgstr "%s: »unset« nicht möglich."

#: builtins/complete_def.cc:269
#, c-format
msgid "%s: invalid action name"
msgstr "%s: Ungültiger Aktionsname."

#: builtins/complete_def.cc:468 builtins/complete_def.cc:603
#: builtins/complete_def.cc:834
#, c-format
msgid "%s: no completion specification"
msgstr "%s: Keine Komplettierung angegeben."

#: builtins/complete_def.cc:657
msgid "warning: -F option may not work as you expect"
msgstr "Warnung: Die Option -F könnte unerwartete Ergebnisse liefern."

#: builtins/complete_def.cc:659
msgid "warning: -C option may not work as you expect"
msgstr "Warnung: Die Option -C könnte unerwartete Ergebnisse liefern."

#: builtins/complete_def.cc:807
msgid "not currently executing completion function"
msgstr "Gegenwärtig wird keine Komplettierungsfunktion ausgeführt."

#: builtins/declare_def.cc:131
msgid "can only be used in a function"
msgstr "Kann nur innerhalb einer Funktion benutzt werden."

#: builtins/declare_def.cc:361 builtins/declare_def.cc:787
#, c-format
msgid "%s: reference variable cannot be an array"
msgstr "%s: Referenzvariable darf kein Array sein."

#: builtins/declare_def.cc:375 variables.cc:3235
#, c-format
msgid "%s: nameref variable self references not allowed"
msgstr ""

#: builtins/declare_def.cc:381 variables.cc:1985 variables.cc:3156
#: variables.cc:3165 variables.cc:3230
#, c-format
msgid "%s: circular name reference"
msgstr "%s: Zirkularbezug auf indirekte Variable."

#: builtins/declare_def.cc:388 builtins/declare_def.cc:797
#: builtins/declare_def.cc:810
#, c-format
msgid "`%s': invalid variable name for name reference"
msgstr "»%s«: Ungültiger Name für indirekte Variablenreferenz."

#: builtins/declare_def.cc:529
msgid "cannot use `-f' to make functions"
msgstr "Mit »-f« können keine Funktionen erzeugt werden."

#: builtins/declare_def.cc:541 execute_cmd.cc:5864
#, c-format
msgid "%s: readonly function"
msgstr "%s: Schreibgeschützte Funktion."

#: builtins/declare_def.cc:868
#, c-format
msgid "%s: quoted compound array assignment deprecated"
msgstr ""

#: builtins/declare_def.cc:887
#, c-format
msgid "%s: cannot destroy array variables in this way"
msgstr "%s: Kann Feldvariablen nicht auf diese Art löschen."

#: builtins/declare_def.cc:895 builtins/read_def.cc:799
#, c-format
msgid "%s: cannot convert associative to indexed array"
msgstr ""
"%s: Konvertieren von assoziativen in indizierte Arrays ist nicht möglich."

#: builtins/enable_def.cc:140 builtins/enable_def.cc:148
msgid "dynamic loading not available"
msgstr "Dynamisches Laden ist nicht verfügbar."

#: builtins/enable_def.cc:334
#, c-format
msgid "cannot open shared object %s: %s"
msgstr "Kann die dynamische Bibliothek nicht laden %s: %s"

#: builtins/enable_def.cc:365
#, c-format
msgid "cannot find %s in shared object %s: %s"
msgstr "Kann %s nicht in der dynamischen Bibliothek finden %s: %s"

#: builtins/enable_def.cc:383
#, c-format
msgid "%s: dynamic builtin already loaded"
msgstr "%s: Ist bereits geladen."

#: builtins/enable_def.cc:388
#, c-format
msgid "load function for %s returns failure (%d): not loaded"
msgstr ""
"Die Ladefunktion von %s lieferte einen Fehler (%d), daher nicht geladen."

#: builtins/enable_def.cc:507
#, c-format
msgid "%s: not dynamically loaded"
msgstr "%s: Ist nicht dynamisch geladen."

#: builtins/enable_def.cc:533
#, c-format
msgid "%s: cannot delete: %s"
msgstr "%s: Kann nicht löschen: %s"

#: builtins/evalfile.cc:131 builtins/hash_def.cc:187 execute_cmd.cc:5696
#, c-format
msgid "%s: is a directory"
msgstr "%s: ist ein Verzeichnis."

#: builtins/evalfile.cc:137
#, c-format
msgid "%s: not a regular file"
msgstr "%s: Ist keine normale Datei."

#: builtins/evalfile.cc:146
#, c-format
msgid "%s: file is too large"
msgstr "%s: Die Datei ist zu groß."

#: builtins/evalfile.cc:181 builtins/evalfile.cc:199 shell.cc:1455
#, c-format
msgid "%s: cannot execute binary file"
msgstr "%s: Kann die Datei nicht ausführen."

#: builtins/exec_def.cc:153 builtins/exec_def.cc:156 builtins/exec_def.cc:243
#, c-format
msgid "%s: cannot execute: %s"
msgstr "%s: Kann nicht ausführen: %s"

#: builtins/exit_def.cc:65
#, c-format
msgid "logout\n"
msgstr "Abgemeldet\n"

#: builtins/exit_def.cc:89
msgid "not login shell: use `exit'"
msgstr "Keine Loginshell: Mit »exit« abmelden!"

#: builtins/exit_def.cc:121
#, c-format
msgid "There are stopped jobs.\n"
msgstr "Es gibt noch angehaltene Prozesse.\n"

#: builtins/exit_def.cc:123
#, c-format
msgid "There are running jobs.\n"
msgstr "Es gibt noch laufende Prozesse.\n"

#: builtins/fc_def.cc:275 builtins/fc_def.cc:379 builtins/fc_def.cc:423
msgid "no command found"
msgstr "Kein Kommando gefunden."

#: builtins/fc_def.cc:369 builtins/fc_def.cc:374 builtins/fc_def.cc:413
#: builtins/fc_def.cc:418
msgid "history specification"
msgstr ""

#: builtins/fc_def.cc:452
#, c-format
msgid "%s: cannot open temp file: %s"
msgstr "%s: Kann die temporäre Datei nicht öffnen: %s"

#: builtins/fg_bg_def.cc:149 builtins/jobs_def.cc:281
msgid "current"
msgstr "gegenwärtig"

#: builtins/fg_bg_def.cc:158
#, c-format
msgid "job %d started without job control"
msgstr "Job %d wurde ohne Jobsteuerung gestartet."

#: builtins/getopt.cc:109
#, c-format
msgid "%s: illegal option -- %c\n"
msgstr "%s: Ungültige Option -- %c\n"

#: builtins/getopt.cc:111
#, c-format
msgid "%s: option requires an argument -- %c\n"
msgstr "%s: Diese Option erfordert ein Argument -- %c\n"

#: builtins/hash_def.cc:89
msgid "hashing disabled"
msgstr "Hashing deaktiviert."

#: builtins/hash_def.cc:141
#, c-format
msgid "%s: hash table empty\n"
msgstr "%s: Die Hashtabelle ist leer.\n"

#: builtins/hash_def.cc:264
#, c-format
msgid "hits\tcommand\n"
msgstr "Treffer\tBefehl\n"

# https://lists.gnu.org/archive/html/bug-bash/2019-09/msg00022.html
#: builtins/help_def.cc:123
msgid "Shell commands matching keyword `"
msgid_plural "Shell commands matching keywords `"
msgstr[0] "Shellkommando, auf das das Schlüsselwort zutrifft `"
msgstr[1] "Shell Kommandos auf die die Schlüsselwörter zutreffen `"

#: builtins/help_def.cc:127
msgid ""
"'\n"
"\n"
msgstr ""
"'\n"
"\n"

#: builtins/help_def.cc:178
#, c-format
msgid ""
"no help topics match `%s'.  Try `help help' or `man -k %s' or `info %s'."
msgstr ""
"Kein passendes Hilfethema für »%s«. Probieren Sie »help help«, »man -k %s« "
"oder »info %s«."

#: builtins/help_def.cc:214
#, c-format
msgid "%s: cannot open: %s"
msgstr "%s: Kann die Datei nicht öffnen: %s"

#: builtins/help_def.cc:485
#, c-format
msgid ""
"These shell commands are defined internally.  Type `help' to see this list.\n"
"Type `help name' to find out more about the function `name'.\n"
"Use `info bash' to find out more about the shell in general.\n"
"Use `man -k' or `info' to find out more about commands not in this list.\n"
"\n"
"A star (*) next to a name means that the command is disabled.\n"
"\n"
msgstr ""
"Diese Shellkommandos sind intern definiert. Geben Sie »help« ein, um diese\n"
"Liste zu sehen. Geben Sie »help Name« ein, um die Beschreibung der Funktion\n"
"»Name« zu sehen. Geben Sie »info bash« ein, um die vollständige "
"Dokumentation\n"
"zu sehen. Geben Sie »man -k« oder »info« ein, um detaillierte "
"Beschreibungen\n"
"der Shellkommandos zu sehen.\n"
"\n"
"Ein Stern (*) neben dem Namen kennzeichnet deaktivierte Kommandos.\n"
"\n"

#: builtins/history_def.cc:152
msgid "cannot use more than one of -anrw"
msgstr "Es darf höchstens eine Option aus -anrw angegeben werden."

#: builtins/history_def.cc:189 builtins/history_def.cc:199
#: builtins/history_def.cc:214 builtins/history_def.cc:232
#: builtins/history_def.cc:244 builtins/history_def.cc:253
msgid "history position"
msgstr "Kommandostapelposition."

#: builtins/history_def.cc:342
#, c-format
msgid "%s: invalid timestamp"
msgstr "%s: Ungültiger Zeitstempel."

#: builtins/history_def.cc:448
#, c-format
msgid "%s: history expansion failed"
msgstr "%s: Kommandoersetzung gescheitert."

#: builtins/jobs_def.cc:112
msgid "no other options allowed with `-x'"
msgstr "Keine weiteren Optionen mit `-x' erlaubt."

#: builtins/kill_def.cc:207
#, c-format
msgid "%s: arguments must be process or job IDs"
msgstr "%s: Die Argumente müssen Prozess- oder Job-IDs sein."

#: builtins/kill_def.cc:267
msgid "Unknown error"
msgstr "Unbekannter Fehler."

#: builtins/let_def.cc:96 expr.cc:439 expr.cc:457
msgid "expression expected"
msgstr "Ausdruck erwartet."

#: builtins/mapfile_def.cc:163
#, c-format
msgid "%s: not an indexed array"
msgstr "%s: Ist kein indiziertes Array."

#: builtins/mapfile_def.cc:255 builtins/read_def.cc:280
#, c-format
msgid "%s: invalid file descriptor specification"
msgstr "%s: Ungültige Dateideskriptor-Angabe."

#: builtins/mapfile_def.cc:264 builtins/read_def.cc:288
#, c-format
msgid "%d: invalid file descriptor: %s"
msgstr "%d: Ungültiger Dateideskriptor: %s"

#: builtins/mapfile_def.cc:274 builtins/mapfile_def.cc:312
#, c-format
msgid "%s: invalid line count"
msgstr "%s: Ungültige Zeilenanzahlangabe."

#: builtins/mapfile_def.cc:285
#, c-format
msgid "%s: invalid array origin"
msgstr "%s: Ungültiger Arrayanfang."

#: builtins/mapfile_def.cc:302
#, c-format
msgid "%s: invalid callback quantum"
msgstr ""

#: builtins/mapfile_def.cc:335
msgid "empty array variable name"
msgstr "Fehlender Name für die Arrayvariable."

#: builtins/mapfile_def.cc:356
msgid "array variable support required"
msgstr ""
"Die Unterstützung für Arrayvariablen ist in dieser Shell nicht vorhanden."

#: builtins/printf_def.cc:408
#, c-format
msgid "`%s': missing format character"
msgstr "»%s«: Fehlendes Formatierungszeichen."

#: builtins/printf_def.cc:464
#, c-format
msgid "`%c': invalid time format specification"
msgstr "»%c«: Ungültige Zeitformatangabe."

#: builtins/printf_def.cc:671
#, c-format
msgid "`%c': invalid format character"
msgstr "»%c«: Ungültiges Formatierungszeichen."

#: builtins/printf_def.cc:696
#, c-format
msgid "warning: %s: %s"
msgstr "Warnung: %s: %s"

#: builtins/printf_def.cc:782
#, c-format
msgid "format parsing problem: %s"
msgstr "Formatleseproblem: %s"

#: builtins/printf_def.cc:894
msgid "missing hex digit for \\x"
msgstr "Fehlende hexadezimale Ziffer nach \\x."

#: builtins/printf_def.cc:909
#, c-format
msgid "missing unicode digit for \\%c"
msgstr "Fehlende Unicode-Ziffer für \\%c."

#: builtins/pushd_def.cc:189
msgid "no other directory"
msgstr "kein anderes Verzeichnis"

#: builtins/pushd_def.cc:357
#, c-format
msgid "%s: invalid argument"
msgstr "%s: Ungültiges Argument."

#: builtins/pushd_def.cc:480
msgid "<no current directory>"
msgstr "<kein aktuelles Verzeichnis>"

#: builtins/pushd_def.cc:523
msgid "directory stack empty"
msgstr "Der Verzeichnisstapel ist leer."

#: builtins/pushd_def.cc:525
msgid "directory stack index"
msgstr "Verzeichnisstapelindex"

#: builtins/pushd_def.cc:677
msgid ""
"Display the list of currently remembered directories.  Directories\n"
"    find their way onto the list with the `pushd' command; you can get\n"
"    back up through the list with the `popd' command.\n"
"    \n"
"    Options:\n"
"      -c\tclear the directory stack by deleting all of the elements\n"
"      -l\tdo not print tilde-prefixed versions of directories relative\n"
"    \tto your home directory\n"
"      -p\tprint the directory stack with one entry per line\n"
"      -v\tprint the directory stack with one entry per line prefixed\n"
"    \twith its position in the stack\n"
"    \n"
"    Arguments:\n"
"      +N\tDisplays the Nth entry counting from the left of the list shown "
"by\n"
"    \tdirs when invoked without options, starting with zero.\n"
"    \n"
"      -N\tDisplays the Nth entry counting from the right of the list shown "
"by\n"
"\tdirs when invoked without options, starting with zero."
msgstr ""
"Zeigt die Liste der gegenwärtig gespeicherten Verzeichnisse an.  Durch\n"
"    das Kommando »pushd« werden die Verzeichnisse auf den Stapel gelegt\n"
"    und können durch das Kommando »popd« wieder vom Stapel entfernt\n"
"    werden.\n"
"\n"
"    Optionen:\n"
"\t-c\tVerzeichnisstapel durch Löschen aller Einträge bereinigen.\n"
"\t-l\tDas Heimatverzeichnis wird nicht mit vorangestellter Tilde\n"
"\tausgegeben\n"
"\t-p\tDen Verzeichnisstapel zeilenweise ausgeben.\n"
"\t-v\tDen Verzeichnisstapel zeilenweise mit vorangestellter\n"
"\tPositionsnummer auseben.\n"
"\n"
"    Argumente:\n"
"\t+N\tZeigt den N'ten Eintrag von links an, der von »dirs« ausgegeben\n"
"\twird, wenn es ohne Optionen aufgerufen wird, beginnend mit Null.\n"
"\t-N\tZeigt den N'ten Eintrag von rechts an, der von »dirs« ausgegeben\n"
"\twird, wenn es ohne Optionen aufgerufen wird, beginnend mit Null."

#: builtins/pushd_def.cc:699
msgid ""
"Adds a directory to the top of the directory stack, or rotates\n"
"    the stack, making the new top of the stack the current working\n"
"    directory.  With no arguments, exchanges the top two directories.\n"
"    \n"
"    Options:\n"
"      -n\tSuppresses the normal change of directory when adding\n"
"    \tdirectories to the stack, so only the stack is manipulated.\n"
"    \n"
"    Arguments:\n"
"      +N\tRotates the stack so that the Nth directory (counting\n"
"    \tfrom the left of the list shown by `dirs', starting with\n"
"    \tzero) is at the top.\n"
"    \n"
"      -N\tRotates the stack so that the Nth directory (counting\n"
"    \tfrom the right of the list shown by `dirs', starting with\n"
"    \tzero) is at the top.\n"
"    \n"
"      dir\tAdds DIR to the directory stack at the top, making it the\n"
"    \tnew current working directory.\n"
"    \n"
"    The `dirs' builtin displays the directory stack."
msgstr ""
"Legt einen Verzeichniseintrag auf den Verzeichnisstapel ab oder rotiert\n"
"den Stapel so, dass das aktuelle Verzeichnis oben liegt. Ohne Argumente\n"
"werden die beiden oberen Einträge vertauscht.\n"
"\n"
"    Optionen: \n"
"       -n\tVermeidet das Wechseln des Verzeichnisses, so dass\n"
"\tnur der Verzeichnisstapel geändert wird.\n"
"\n"
"    Argumente:\n"
"      +N\tRotiert den Verzeichnisstapel, dass das N-te Verzeichnis\n"
"\tvon links, das von »dirs« angezeigt wird, nach oben kommt. Die Zählung\n"
"\tbeginnt dabei mit Null.\n"
"\n"
"      -N\tRotiert den Verzeichnisstapel, dass das N-te Verzeichnis\n"
"\tvon rechts, das von »dirs« angezeigt wird, nach oben kommt. Die \n"
"\tZählung beginnt dabei mit Null.\n"
"\n"
"      dir\tLegt DIR auf den Verzeichnisstapel und wechselt in dieses\n"
"      Verzeichnis.\n"
"    \n"
"    Das Kommando »dirs« Kommando zeigt den Verzeichnisstapel an."

#: builtins/pushd_def.cc:723
msgid ""
"Removes entries from the directory stack.  With no arguments, removes\n"
"    the top directory from the stack, and changes to the new top directory.\n"
"    \n"
"    Options:\n"
"      -n\tSuppresses the normal change of directory when removing\n"
"    \tdirectories from the stack, so only the stack is manipulated.\n"
"    \n"
"    Arguments:\n"
"      +N\tRemoves the Nth entry counting from the left of the list\n"
"    \tshown by `dirs', starting with zero.  For example: `popd +0'\n"
"    \tremoves the first directory, `popd +1' the second.\n"
"    \n"
"      -N\tRemoves the Nth entry counting from the right of the list\n"
"    \tshown by `dirs', starting with zero.  For example: `popd -0'\n"
"    \tremoves the last directory, `popd -1' the next to last.\n"
"    \n"
"    The `dirs' builtin displays the directory stack."
msgstr ""
"Entfernt Einträge vom Stapel.  Ohne Argumente wird der oberste Eintrag\n"
"    gelöscht und anschließend in das das neue oben liegende Verzeichnis\n"
"    gewechselt.\n"
"    \n"
"    Optionen:\n"
"      -n\tVermeidet das Wechseln des Verzeichnisses, so dass\n"
"\tnur der Verzeichnisstapel geändert wird.\n"
"    \n"
"    Argumente:\n"
"      +N\tEntfernt den N-ten Eintrag von links, der von `dirs'\n"
"\tangezeigt wird.  Dabei beginnt die Zählung von Null.  So\n"
"\tentfernt z.B. »popd +0« den ersten und »popd +1« den zweiten\n"
"\tEintrag.\n"
"    \n"
"      -N\tEntfernt den N-ten Eintrag von rechts, der von `dirs'\n"
"\tangezeigt wird.  Dabei beginnt die Zählung von Null.  So\n"
"\tentfernt z.B. »popd -0« den letzten und »popd +1« den vorletzten\n"
"\tEintrag.\n"
"    \n"
"    Das Kommando »dirs« zeigt den Verzeichnisstapel an."

#: builtins/read_def.cc:251
#, c-format
msgid "%s: invalid timeout specification"
msgstr "%s: Ungültige Wartezeitangebe."

#: builtins/read_def.cc:739
#, c-format
msgid "read error: %d: %s"
msgstr "Lesefehler: %d: %s"

#: builtins/return_def.cc:67
msgid "can only `return' from a function or sourced script"
msgstr ""
"»Return« ist nur aus einer Funktion oder einem mit »source« ausgeführten "
"Skript möglich."

#: builtins/set_def.cc:824
msgid "cannot simultaneously unset a function and a variable"
msgstr ""
"Gleichzeitiges »unset« einer Funktion und einer Variable ist nicht möglich."

#: builtins/set_def.cc:927
#, c-format
msgid "%s: not an array variable"
msgstr "%s: Ist keine Feldvariable."

#: builtins/setattr_def.cc:176
#, c-format
msgid "%s: not a function"
msgstr "%s: Ist keine Funktion."

#: builtins/setattr_def.cc:182
#, c-format
msgid "%s: cannot export"
msgstr "%s: Exportieren nicht möglich."

#: builtins/shift_def.cc:72 builtins/shift_def.cc:79
msgid "shift count"
msgstr "Verschiebeanzahl"

#: builtins/shopt_def.cc:240
msgid "cannot set and unset shell options simultaneously"
msgstr "Kann nicht Shelloptionen gleichzeitig aktivieren und deaktivieren."

#: builtins/shopt_def.cc:358
#, c-format
msgid "%s: invalid shell option name"
msgstr "%s: Ungültiger Name für Shelloption."

#: builtins/source_def.cc:126
msgid "filename argument required"
msgstr "Ein Dateiname wird als Argument benötigt."

#: builtins/source_def.cc:152
#, c-format
msgid "%s: file not found"
msgstr "%s: Datei nicht gefunden."

#: builtins/suspend_def.cc:99
msgid "cannot suspend"
msgstr "Kann die Shell nicht unterbrechen."

# logout
#: builtins/suspend_def.cc:109
msgid "cannot suspend a login shell"
msgstr "Kann die Loginshell nicht unterbrechen."

#: builtins/type_def.cc:223
#, c-format
msgid "%s is aliased to `%s'\n"
msgstr "%s ist ein Alias von »%s«.\n"

#: builtins/type_def.cc:244
#, c-format
msgid "%s is a shell keyword\n"
msgstr "%s Ist ein reserviertes Schlüsselwort der Shell.\n"

#: builtins/type_def.cc:263
#, c-format
msgid "%s is a function\n"
msgstr "%s ist eine Funktion.\n"

#: builtins/type_def.cc:288
#, c-format
msgid "%s is a special shell builtin\n"
msgstr "%s ist eine spezielle eingebaute Funktion.\n"

#: builtins/type_def.cc:290
#, c-format
msgid "%s is a shell builtin\n"
msgstr "%s ist eine von der Shell mitgelieferte Funktion.\n"

#: builtins/type_def.cc:312 builtins/type_def.cc:401
#, c-format
msgid "%s is %s\n"
msgstr "%s ist %s\n"

#: builtins/type_def.cc:332
#, c-format
msgid "%s is hashed (%s)\n"
msgstr "%s ist gehasht (%s)\n"

#: builtins/ulimit_def.cc:395
#, c-format
msgid "%s: invalid limit argument"
msgstr "%s: Ungültiges Grenzwertargument."

#: builtins/ulimit_def.cc:423
#, c-format
msgid "`%c': bad command"
msgstr "`%c': Falsches Kommando."

#: builtins/ulimit_def.cc:450
#, c-format
msgid "%s: cannot get limit: %s"
msgstr "%s: Kann die nicht Grenze setzen: %s"

#: builtins/ulimit_def.cc:477
msgid "limit"
msgstr "Grenze"

#: builtins/ulimit_def.cc:489 builtins/ulimit_def.cc:775
#, c-format
msgid "%s: cannot modify limit: %s"
msgstr "%s: Kann die Grenze nicht ändern: %s"

#: builtins/umask_def.cc:117
msgid "octal number"
msgstr "Oktalzahl"

#: builtins/umask_def.cc:227
#, c-format
msgid "`%c': invalid symbolic mode operator"
msgstr "`%c': Ungültiger Operator für den symbolischen Modus."

#: builtins/umask_def.cc:282
#, c-format
msgid "`%c': invalid symbolic mode character"
msgstr "`%c': Ungültiges Zeichen im symbolischen Modus."

#: error.cc:54 error.cc:280 error.cc:283 error.cc:286
msgid " line "
msgstr " Zeile "

#: error.cc:122
#, c-format
msgid "last command: %s\n"
msgstr "Letztes Kommando: %s\n"

#: error.cc:130
#, c-format
msgid "Aborting..."
msgstr "Abbruch..."

#. TRANSLATORS: this is a prefix for informational messages.
#: error.cc:215
#, c-format
msgid "INFORM: "
msgstr "INFO: "

#: error.cc:232
#, fuzzy, c-format
msgid "DEBUG warning: "
msgstr "Warnung: "

#: error.cc:327
msgid "unknown command error"
msgstr "Unbekanntes Kommando"

#: error.cc:328
msgid "bad command type"
msgstr "Falscher Kommandotyp"

# Programmierfehler
#: error.cc:329
msgid "bad connector"
msgstr ""

#: error.cc:330
msgid "bad jump"
msgstr "Falscher Sprung"

#: error.cc:354
#, c-format
msgid "%s: unbound variable"
msgstr "%s ist nicht gesetzt."

#: eval.cc:238
msgid "\atimed out waiting for input: auto-logout\n"
msgstr "\aZu lange keine Eingabe: Automatisch ausgeloggt.\n"

#: execute_cmd.cc:440
#, c-format
msgid "cannot redirect standard input from /dev/null: %s"
msgstr "Kann nicht die Standardeingabe von /dev/null umleiten: %s"

#: execute_cmd.cc:1216
#, c-format
msgid "TIMEFORMAT: `%c': invalid format character"
msgstr "TIMEFORMAT: »%c«: Ungültiges Formatzeichen."

#: execute_cmd.cc:2251
#, c-format
msgid "execute_coproc: coproc [%d:%s] still exists"
msgstr ""

#: execute_cmd.cc:2375
msgid "pipe error"
msgstr "Pipe-Fehler"

#: execute_cmd.cc:4678
#, c-format
msgid "eval: maximum eval nesting level exceeded (%d)"
msgstr "eval: Maximale Schachtelungstiefe überschritten (%d)"

#: execute_cmd.cc:4691
#, c-format
msgid "%s: maximum source nesting level exceeded (%d)"
msgstr "%s: Maximale Quellcode-Schachtelungstiefe überschritten (%d)"

#: execute_cmd.cc:4790
#, c-format
msgid "%s: maximum function nesting level exceeded (%d)"
msgstr "%s: maximale Schachtelungstiefe für Funktionen überschritten (%d)"

#: execute_cmd.cc:5341
#, c-format
msgid "%s: restricted: cannot specify `/' in command names"
msgstr "%s: eingeschränkt: `/' ist in Kommandonamen unzulässig."

#: execute_cmd.cc:5456
#, c-format
msgid "%s: command not found"
msgstr "%s: Kommando nicht gefunden."

#: execute_cmd.cc:5694
#, c-format
msgid "%s: %s"
msgstr "%s: %s"

#: execute_cmd.cc:5732
#, c-format
msgid "%s: %s: bad interpreter"
msgstr "%s: %s: Defekter Interpreter"

#: execute_cmd.cc:5770
#, c-format
msgid "%s: cannot execute binary file: %s"
msgstr "%s: Kann die Binärdatei nicht ausführen: %s"

#: execute_cmd.cc:5855
#, c-format
msgid "`%s': is a special builtin"
msgstr "»%s« ist eine spezielle eingebaute Funktion."

#: execute_cmd.cc:5888
#, c-format
msgid "cannot duplicate fd %d to fd %d"
msgstr "Kann fd %d nicht auf fd %d verdoppeln."

#: expr.cc:111
msgid "expression recursion level exceeded"
msgstr "Zu viele Rekursionen in Ausdruck."

#: expr.cc:128
msgid "recursion stack underflow"
msgstr "Rekursionsstapel leer."

#: expr.cc:284
msgid "syntax error in expression"
msgstr "Syntaxfehler im Ausdruck."

#: expr.cc:327
msgid "attempted assignment to non-variable"
msgstr "Versuchte Zuweisung zu etwas, das keine Variable ist."

#: expr.cc:336
msgid "syntax error in variable assignment"
msgstr "Syntaxfehler in der Variablenzuweisung."

#: expr.cc:349 expr.cc:706
msgid "division by 0"
msgstr "Division durch 0."

#: expr.cc:396
msgid "bug: bad expassign token"
msgstr "Fehler: Falscher Zuweisungsoperator."

#: expr.cc:446
msgid "`:' expected for conditional expression"
msgstr "»:« für ein bedingten Ausdruck erwartet."

#: expr.cc:766
msgid "exponent less than 0"
msgstr "Der Exponent ist kleiner als 0."

#: expr.cc:823
msgid "identifier expected after pre-increment or pre-decrement"
msgstr ""
"Nach einem Präinkrement oder Prädekrement wird ein Bezeichner erwartet."

#: expr.cc:851
msgid "missing `)'"
msgstr "Fehlende »)«"

#: expr.cc:902 expr.cc:1253
msgid "syntax error: operand expected"
msgstr "Syntaxfehler: Operator erwartet."

#: expr.cc:1255
msgid "syntax error: invalid arithmetic operator"
msgstr "Syntaxfehler: Ungültiger arithmetischer Operator."

#: expr.cc:1278
#, c-format
msgid "%s%s%s: %s (error token is \"%s\")"
msgstr "%s%s%s: %s (Fehlerverursachendes Zeichen ist \"%s\")."

#: expr.cc:1337
msgid "invalid arithmetic base"
msgstr "Ungültige Basis."

#: expr.cc:1347
msgid "invalid integer constant"
msgstr "Ungültige Ganzzahlenkonstante."

#: expr.cc:1363
msgid "value too great for base"
msgstr "Der Wert ist für die aktuelle Basis zu groß."

#: input.cc:83 subst.cc:5317
#, c-format
msgid "cannot reset nodelay mode for fd %d"
msgstr "Konnte den No-Delay-Modus für fd %d nicht wiederherstellen."

#: input.cc:163
#, c-format
msgid "cannot allocate new file descriptor for bash input from fd %d"
msgstr "Kann keinen neuen Dateideskriptor für die Eingabe von fd %d zuweisen."

# Debug Ausgabe
#: input.cc:175
#, c-format
msgid "save_bash_input: buffer already exists for new fd %d"
msgstr "save_bash_input: Es existiert bereits ein Puffer für den neuen fd %d."

#: jobs.cc:309
msgid "start_pipeline: pgrp pipe"
msgstr "start_pipeline: pgrp pipe"

#: jobs.cc:679
#, c-format
msgid "bgp_delete: LOOP: psi (%d) == storage[psi].bucket_next"
msgstr ""

#: jobs.cc:734
#, c-format
msgid "bgp_search: LOOP: psi (%d) == storage[psi].bucket_next"
msgstr ""

#: jobs.cc:1036
#, c-format
msgid "forked pid %d appears in running job %d"
msgstr "Die geforkte PID %d erscheint im laufenden Prozess %d."

#: jobs.cc:1156
#, c-format
msgid "deleting stopped job %d with process group %ld"
msgstr "Lösche den gestoppten Prozess %d der Prozessgruppe %ld."

# https://lists.gnu.org/archive/html/bug-bash/2019-09/msg00024.html
#: jobs.cc:1266
#, c-format
msgid "add_process: pid %5ld (%s) marked as still alive"
msgstr ""

# Programmierfehler
#: jobs.cc:1593
#, c-format
msgid "describe_pid: %ld: no such pid"
msgstr "describe_pid: %ld: Prozessnummer existiert nicht."

#: jobs.cc:1607
#, c-format
msgid "Signal %d"
msgstr "Signal %d"

#: jobs.cc:1618 jobs.cc:1645
msgid "Done"
msgstr "Fertig"

#: jobs.cc:1623 siglist.cc:124
msgid "Stopped"
msgstr "Angehalten"

#: jobs.cc:1627
#, c-format
msgid "Stopped(%s)"
msgstr "Angehalten(%s)"

#: jobs.cc:1632
msgid "Running"
msgstr "Läuft"

#: jobs.cc:1649
#, c-format
msgid "Done(%d)"
msgstr "Fertig(%d)"

#: jobs.cc:1651
#, c-format
msgid "Exit %d"
msgstr "Exit %d"

#: jobs.cc:1654
msgid "Unknown status"
msgstr "Unbekannter Status"

#: jobs.cc:1738
#, c-format
msgid "(core dumped) "
msgstr "(Speicherabzug geschrieben) "

#: jobs.cc:1756
#, c-format
msgid "  (wd: %s)"
msgstr "  (Verz.: %s)"

# interner Fehler
#: jobs.cc:1987
#, c-format
msgid "child setpgid (%ld to %ld)"
msgstr ""

#: jobs.cc:2341 nojobs.cc:641
#, c-format
msgid "wait: pid %ld is not a child of this shell"
msgstr "wait: Prozess %ld wurde nicht von dieser Shell gestartet."

#: jobs.cc:2619
#, c-format
msgid "wait_for: No record of process %ld"
msgstr ""

#: jobs.cc:2975
#, c-format
msgid "wait_for_job: job %d is stopped"
msgstr "wait_for_job: Der Job %d ist gestoppt."

#: jobs.cc:3292
#, c-format
msgid "%s: no current jobs"
msgstr "%s: Kein aktueller Job."

#: jobs.cc:3299
#, c-format
msgid "%s: job has terminated"
msgstr "%s: Der Job ist beendet."

#: jobs.cc:3308
#, c-format
msgid "%s: job %d already in background"
msgstr "%s: Der Job %d läuft bereits im Hintergrund."

#: jobs.cc:3534
msgid "waitchld: turning on WNOHANG to avoid indefinite block"
msgstr ""

# Debug Ausgabe
#: jobs.cc:4055
#, c-format
msgid "%s: line %d: "
msgstr "%s: Zeile %d: "

#: jobs.cc:4071 nojobs.cc:897
#, c-format
msgid " (core dumped)"
msgstr " (Speicherabzug geschrieben)"

#: jobs.cc:4082 jobs.cc:4095
#, c-format
msgid "(wd now: %s)\n"
msgstr "(gegenwärtiges Arbeitsverzeichnis ist: %s)\n"

# interner Fehler
#: jobs.cc:4127
msgid "initialize_job_control: getpgrp failed"
msgstr "initialize_job_control: getpgrp war nicht erfolgreich."

# interner Fehler
#: jobs.cc:4184
msgid "initialize_job_control: no job control in background"
msgstr "initialize_job_control: Keine Jobsteuerung im Hintergrund."

# interner Fehler
#: jobs.cc:4201
msgid "initialize_job_control: line discipline"
msgstr "initialize_job_control: line discipline"

# interner Fehler
#: jobs.cc:4211
msgid "initialize_job_control: setpgid"
msgstr "initialize_job_control: setpgid"

#: jobs.cc:4232 jobs.cc:4243
#, c-format
msgid "cannot set terminal process group (%d)"
msgstr "Kann die Prozessgruppe des Terminals nicht setzen (%d)."

#: jobs.cc:4248
msgid "no job control in this shell"
msgstr "Keine Jobsteuerung in dieser Shell."

#: lib/sh/fmtulong.cc:81
msgid "invalid base"
msgstr "Ungültige Basis"

#: lib/sh/netopen.cc:152
#, c-format
msgid "%s: host unknown"
msgstr "%s: Unbekannter Host."

#: lib/sh/netopen.cc:159
#, c-format
msgid "%s: invalid service"
msgstr "%s: unbekannter Dienst."

#: lib/sh/netopen.cc:270
#, c-format
msgid "%s: bad network path specification"
msgstr "%s: Fehlerhafte Netzwerkspfadangabe."

#: lib/sh/netopen.cc:291
msgid "network operations not supported"
msgstr "Der Netzwerkbetrieb ist nicht unterstützt."

#: locale.cc:201
#, c-format
msgid "setlocale: LC_ALL: cannot change locale (%s)"
msgstr "setlocale: LC_ALL: Kann die Regionseinstellungen nicht ändern (%s)."

#: locale.cc:204
#, c-format
msgid "setlocale: LC_ALL: cannot change locale (%s): %s"
msgstr "setlocale: LC_ALL: Kann die Regionseinstellungen nicht ändern (%s): %s"

#: locale.cc:286
#, c-format
msgid "setlocale: %s: cannot change locale (%s)"
msgstr "setlocale: %s: Kann die Regionseinstellungen nicht ändern (%s)."

#: locale.cc:289
#, c-format
msgid "setlocale: %s: cannot change locale (%s): %s"
msgstr "setlocale: %s: Kann die Regionseinstellungen nicht ändern (%s): %s"

# Du oder Sie?
#: mailcheck.cc:433
msgid "You have mail in $_"
msgstr "Sie haben Post in $_."

#: mailcheck.cc:458
msgid "You have new mail in $_"
msgstr "Sie haben neue Post in $_."

#: mailcheck.cc:475
#, c-format
msgid "The mail in %s has been read\n"
msgstr "Die Post in %s wurde bereits gelesen.\n"

#: make_cmd.cc:106
msgid "syntax error: arithmetic expression required"
msgstr "Syntaxfehler: Es wird ein arithmetischer Ausdruck benötigt."

#: make_cmd.cc:108
msgid "syntax error: `;' unexpected"
msgstr "Syntax Fehler: unerwartetes `;'."

#: make_cmd.cc:109
#, c-format
msgid "syntax error: `((%s))'"
msgstr "Syntaxfehler: »((%s))«."

# interner Fehler
#: make_cmd.cc:318
#, c-format
msgid "make_here_document: bad instruction type %d"
msgstr "make_here_document: Falscher Befehlstyp %d."

#: make_cmd.cc:405
#, c-format
msgid "here-document at line %d delimited by end-of-file (wanted `%s')"
msgstr ""
"Das in der Zeile %d beginnende Here-Dokument geht bis zum Dateiende "
"(erwartet wird »%s«)."

#: make_cmd.cc:502
#, c-format
msgid "make_redirection: redirection instruction `%d' out of range"
msgstr ""

#: pcomplete.cc:1068
#, c-format
msgid "completion: function `%s' not found"
msgstr "completion: Funktion »%s« nicht gefunden."

#: pcomplete.cc:1656
#, c-format
msgid "programmable_completion: %s: possible retry loop"
msgstr ""

#: pcomplib.cc:173
#, c-format
msgid "progcomp_insert: %s: NULL COMPSPEC"
msgstr ""

#: print_cmd.cc:85
#, c-format
msgid "xtrace_set: %d: invalid file descriptor"
msgstr "xtrace_set: %d: Ungültiger Dateideskriptor."

#: print_cmd.cc:90
msgid "xtrace_set: NULL file pointer"
msgstr ""

#: print_cmd.cc:94
#, c-format
msgid "xtrace fd (%d) != fileno xtrace fp (%d)"
msgstr ""

#: print_cmd.cc:1057
#, c-format
msgid "print_command: bad connector `%d'"
msgstr "print_command: Falsches Verbindungszeichen »%d«."

#: print_cmd.cc:1148
#, c-format
msgid "cprintf: `%c': invalid format character"
msgstr "cprintf: »%c«: Ungültiges Formatsymbol."

#: redir.cc:137 redir.cc:186
msgid "file descriptor out of range"
msgstr "Dateideskriptor außerhalb des gültigen Bereichs."

#: redir.cc:193
#, c-format
msgid "%s: ambiguous redirect"
msgstr "%s: Mehrdeutige Umlenkung."

#: redir.cc:197
#, c-format
msgid "%s: cannot overwrite existing file"
msgstr "%s: Kann existierende Datei nicht überschreiben."

#: redir.cc:202
#, c-format
msgid "%s: restricted: cannot redirect output"
msgstr "%s: eingeschränkt: Die Ausgabe darf nicht umgeleitet werden."

#: redir.cc:207
#, c-format
msgid "cannot create temp file for here-document: %s"
msgstr "Kann die temporäre Datei für das Hier-Dokument nicht anlegen: %s"

#: redir.cc:212
#, c-format
msgid "%s: cannot assign fd to variable"
msgstr "%s: Kann fd keiner Variable zuweisen."

#: redir.cc:628
msgid "/dev/(tcp|udp)/host/port not supported without networking"
msgstr ""
"Dateinamen der Form /dev/(tcp|udp)/host/port werden ohne Netzwerk nicht "
"unterstützt"

#: redir.cc:902 redir.cc:1019 redir.cc:1083 redir.cc:1258
msgid "redirection error: cannot duplicate fd"
msgstr "Umleitungsfehler: Verdoppeln des Dateibezeichners nicht möglich."

#: shell.cc:80 shell.cc:95
#, c-format
msgid "unhandled exception: %s"
msgstr ""

#: shell.cc:143
msgid "could not find /tmp, please create!"
msgstr "Konnte das Verzeichnis »/tmp« nicht finden, bitte anlegen."

#: shell.cc:147
msgid "/tmp must be a valid directory name"
msgstr "/tmp muss ein Verzeichnis sein."

#: shell.cc:619
msgid "pretty-printing mode ignored in interactive shells"
msgstr "Der hübsche Druckmodus wird in interaktiven Schells ignoriert."

#: shell.cc:783
#, c-format
msgid "%c%c: invalid option"
msgstr "%c%c: Ungültige Option"

#: shell.cc:1134
#, c-format
msgid "cannot set uid to %d: effective uid %d"
msgstr "Konnte die UID nicht in %d ändern: Die effektive UID ist %d"

#: shell.cc:1146
#, c-format
msgid "cannot set gid to %d: effective gid %d"
msgstr "Konnte die GID nicht in %d ändern: Die effektive GID ist %d"

#: shell.cc:1326
msgid "cannot start debugger; debugging mode disabled"
msgstr "Kann keinen Debugger starten. Der Debugmodus ist gesperrt."

#: shell.cc:1440
#, c-format
msgid "%s: Is a directory"
msgstr "%s: Ist ein Verzeichnis."

#: shell.cc:1823
#, c-format
msgid "GNU bash, version %s-(%s)\n"
msgstr "GNU bash, Version %s-(%s)\n"

#: shell.cc:1826
#, c-format
msgid ""
"Usage:\t%s [GNU long option] [option] ...\n"
"\t%s [GNU long option] [option] script-file ...\n"
msgstr ""
"Aufruf:\t%s [Lange GNU-Option] [Option] ...\n"
"\t%s [Lange GNU-Option] [Option] Script-Datei ...\n"

#: shell.cc:1829
msgid "GNU long options:\n"
msgstr "Lange GNU-Optionen:\n"

#: shell.cc:1834
msgid "Shell options:\n"
msgstr "Shell-Optionen:\n"

#: shell.cc:1836
msgid "\t-ilrsD or -c command or -O shopt_option\t\t(invocation only)\n"
msgstr "\t-ilrsD oder -c Kommando oder -O shopt_option\t\t(Nur Aufruf)\n"

#: shell.cc:1858
#, c-format
msgid "\t-%s or -o option\n"
msgstr "\t-%s oder Option -o\n"

#: shell.cc:1865
#, c-format
msgid "Type `%s -c \"help set\"' for more information about shell options.\n"
msgstr ""
"Geben Sie »%s -c \"help set\"« ein, um mehr über Shell-Optionen zu "
"erfahren.\n"

#: shell.cc:1869
#, c-format
msgid "Type `%s -c help' for more information about shell builtin commands.\n"
msgstr ""
"Geben Sie »%s -c help« ein, um mehr über eingebaute Shellkommandos zu "
"erfahren.\n"

#: shell.cc:1872
#, c-format
msgid "Use the `bashbug' command to report bugs.\n"
msgstr "Mit dem Kommando »bashbug« Kommando können Sie Fehler melden.\n"

#: shell.cc:1875
#, c-format
msgid "bash home page: <http://www.gnu.org/software/bash>\n"
msgstr "Bash-Homepage: <https://www.gnu.org/software/bash>\n"

#: shell.cc:1876
#, c-format
msgid "General help using GNU software: <http://www.gnu.org/gethelp/>\n"
msgstr "Allgemeine Hilfe für GNU-Software: <https://www.gnu.org/gethelp/>\n"

#: sig.cc:686
#, c-format
msgid "sigprocmask: %d: invalid operation"
msgstr "sigprocmask: %d: Ungültige Operation"

#: siglist.cc:49
msgid "Bogus signal"
msgstr "Falsches Signal."

#: siglist.cc:52
msgid "Hangup"
msgstr "Aufgelegt"

#: siglist.cc:56
msgid "Interrupt"
msgstr "Unterbrochen (Interrupt)"

#: siglist.cc:60
msgid "Quit"
msgstr "Quit"

#: siglist.cc:64
msgid "Illegal instruction"
msgstr "Ungültige Anweisung."

#: siglist.cc:68
msgid "BPT trace/trap"
msgstr "Verfolgen/anhalten abfangen (Trace/breakpoint trap)"

#: siglist.cc:76
msgid "ABORT instruction"
msgstr "Abbruchkommando"

#: siglist.cc:80
msgid "EMT instruction"
msgstr "EMT abfangen (EMT trap)"

#: siglist.cc:84
msgid "Floating point exception"
msgstr "Gleitkommafehler"

#: siglist.cc:88
msgid "Killed"
msgstr "Abgebrochen (Killed)"

#: siglist.cc:92
msgid "Bus error"
msgstr "Bus-Fehler"

#: siglist.cc:96
msgid "Segmentation fault"
msgstr "Adressierungsfehler"

#: siglist.cc:100
msgid "Bad system call"
msgstr "Falscher Systemaufruf"

#: siglist.cc:104
msgid "Broken pipe"
msgstr "Unterbrochene Pipe"

#: siglist.cc:108
msgid "Alarm clock"
msgstr "Wecker"

#: siglist.cc:112
msgid "Terminated"
msgstr "Abgebrochen (Terminated)"

#: siglist.cc:116
msgid "Urgent IO condition"
msgstr "Dringende IO-Bedingung"

#: siglist.cc:120
msgid "Stopped (signal)"
msgstr "Angehalten (Signal)"

#: siglist.cc:128
msgid "Continue"
msgstr "Prozessbearbeitung wieder aufgenommen."

#: siglist.cc:136
msgid "Child death or stop"
msgstr "Kindprozess abgebrochen oder gestoppt."

#: siglist.cc:140
msgid "Stopped (tty input)"
msgstr "Angehalten (Terminaleingabe)"

#: siglist.cc:144
msgid "Stopped (tty output)"
msgstr "Angehalten (Terminalausgabe)"

#: siglist.cc:148
msgid "I/O ready"
msgstr "E/A fertig"

#: siglist.cc:152
msgid "CPU limit"
msgstr "Rechenzeitgrenze"

#: siglist.cc:156
msgid "File limit"
msgstr "Grenze für Dateigröße"

#: siglist.cc:160
msgid "Alarm (virtual)"
msgstr "Alarm (Virtuell)"

#: siglist.cc:164
msgid "Alarm (profile)"
msgstr "Alarm (Profil)"

#: siglist.cc:168
msgid "Window changed"
msgstr "Fenster geändert"

#: siglist.cc:172
msgid "Record lock"
msgstr "Datei blockiert"

#: siglist.cc:176
msgid "User signal 1"
msgstr "Nutzersignal 1"

#: siglist.cc:180
msgid "User signal 2"
msgstr "Nutzersignal 2"

#: siglist.cc:184
msgid "HFT input data pending"
msgstr "HFT Eingabedaten ausstehend"

#: siglist.cc:188
msgid "power failure imminent"
msgstr "Spannungsausfall steht bevor"

#: siglist.cc:192
msgid "system crash imminent"
msgstr "Systemausfall steht bevor"

#: siglist.cc:196
msgid "migrate process to another CPU"
msgstr "Verlege den Prozess auf einen anderen Prozessor"

#: siglist.cc:200
msgid "programming error"
msgstr "Programmierfehler"

#: siglist.cc:204
msgid "HFT monitor mode granted"
msgstr "HFT-Monitormodus erlaubt"

#: siglist.cc:208
msgid "HFT monitor mode retracted"
msgstr "HFT-Monitormodus abgeschaltet"

#: siglist.cc:212
msgid "HFT sound sequence has completed"
msgstr "HFT-Tonfolge beendet"

#: siglist.cc:216
msgid "Information request"
msgstr "Informationsanforderung"

# https://lists.gnu.org/archive/html/bug-bash/2019-09/msg00025.html
#: siglist.cc:224 siglist.cc:226
#, c-format
msgid "Unknown Signal #%d"
msgstr "Unbekanntes Signal Nr.: %d."

#: subst.cc:1079 subst.cc:1280
#, c-format
msgid "bad substitution: no closing `%s' in %s"
msgstr "Falsche Ersetzung: Kein schließendes »%s« in »%s« enthalten."

#: subst.cc:2754
#, c-format
msgid "%s: cannot assign list to array member"
msgstr "%s: Kann einem Feldelement keine Liste zuweisen."

#: subst.cc:5157 subst.cc:5173
msgid "cannot make pipe for process substitution"
msgstr "Kann keine Pipe für die Prozessersetzung erzeugen."

#: subst.cc:5233
msgid "cannot make child for process substitution"
msgstr "Kann den Kindsprozess für die Prozessersetzung nicht erzeugen."

#: subst.cc:5307
#, c-format
msgid "cannot open named pipe %s for reading"
msgstr "Kann nicht die benannte Pipe %s zum Lesen öffnen."

#: subst.cc:5309
#, c-format
msgid "cannot open named pipe %s for writing"
msgstr "Kann nicht die benannte Pipe %s zum Schreiben öffnen."

#: subst.cc:5332
#, c-format
msgid "cannot duplicate named pipe %s as fd %d"
msgstr "Kann die benannte Pipe %s nicht auf fd %d duplizieren."

#: subst.cc:5452
msgid "command substitution: ignored null byte in input"
msgstr "Kommandoersetzung: NULL-Byte in der Eingabe ignoriert."

#: subst.cc:5593
msgid "cannot make pipe for command substitution"
msgstr "Kann keine Pipes für Kommandoersetzung erzeugen."

#: subst.cc:5642
msgid "cannot make child for command substitution"
msgstr "Kann keinen Unterprozess für die Kommandoersetzung erzeugen."

# interner Fehler
#: subst.cc:5676
msgid "command_substitute: cannot duplicate pipe as fd 1"
msgstr "command_substitute: Kann Pipe nicht als Dateideskriptor 1 duplizieren."

#: subst.cc:6141 subst.cc:9221
#, c-format
msgid "%s: invalid variable name for name reference"
msgstr "%s: Ungültiger Variablenname für Namensreferenz."

#: subst.cc:6239 subst.cc:6257 subst.cc:6436
#, c-format
msgid "%s: invalid indirect expansion"
msgstr "%s: Ungültige indirekte Expansion."

#: subst.cc:6273 subst.cc:6444
#, c-format
msgid "%s: invalid variable name"
msgstr "%s: Ungültiger Variablenname."

#: subst.cc:6524
#, c-format
msgid "%s: parameter not set"
msgstr "%s: Der Parameter ist nicht gesetzt."

#: subst.cc:6526
#, c-format
msgid "%s: parameter null or not set"
msgstr "%s: Parameter ist leer oder nicht gesetzt."

# interner Fehler
#: subst.cc:6764 subst.cc:6779
#, c-format
msgid "%s: substring expression < 0"
msgstr "%s: Teilstring-Ausdruck < 0."

#: subst.cc:8519 subst.cc:8545
#, c-format
msgid "%s: bad substitution"
msgstr "%s: Falsche Substitution."

#: subst.cc:8645
#, c-format
msgid "$%s: cannot assign in this way"
msgstr "$%s: Kann so nicht zuweisen."

#: subst.cc:9074
msgid ""
"future versions of the shell will force evaluation as an arithmetic "
"substitution"
msgstr ""
"Zukünftige Versionen dieser Shell werden das Auswerten arithmetischer "
"Ersetzungen erzwingen."

#: subst.cc:9642
#, c-format
msgid "bad substitution: no closing \"`\" in %s"
msgstr "Falsche Ersetzung: Kein schließendes »`« in %s."

#: subst.cc:10684
#, c-format
msgid "no match: %s"
msgstr "Keine Entsprechung: %s"

#: test.cc:122
msgid "argument expected"
msgstr "Argument erwartet."

#: test.cc:130
#, c-format
msgid "%s: integer expression expected"
msgstr "%s: Ganzzahliger Ausdruck erwartet."

#: test.cc:255
msgid "`)' expected"
msgstr "»)« erwartet."

#: test.cc:257
#, c-format
msgid "`)' expected, found %s"
msgstr "»)« erwartet, %s gefunden."

#: test.cc:465 test.cc:819
#, c-format
msgid "%s: binary operator expected"
msgstr "%s: Zweistelliger (binärer) Operator erwartet."

#: test.cc:776 test.cc:779
#, c-format
msgid "%s: unary operator expected"
msgstr "%s: Einstelliger (unärer) Operator erwartet."

#: test.cc:898
msgid "missing `]'"
msgstr "Fehlende »]«"

#: test.cc:916
#, c-format
msgid "syntax error: `%s' unexpected"
msgstr "Syntax Fehler: »%s« unerwartet."

#: trap.cc:123
msgid "invalid signal number"
msgstr "Ungültige Signalnummer."

#: trap.cc:232
#, c-format
msgid "trap handler: maximum trap handler level exceeded (%d)"
msgstr "Traphandler: Maximale Traphandler-Ebene überschritten (%d)"

#: trap.cc:322
#, c-format
msgid "run_pending_traps: bad value in trap_list[%d]: %p"
msgstr "run_pending_traps: Ungültiger Wert in trap_list[%d]: %p"

#: trap.cc:326
#, c-format
msgid ""
"run_pending_traps: signal handler is SIG_DFL, resending %d (%s) to myself"
msgstr ""

# Programmierfehler
#: trap.cc:430
#, c-format
msgid "trap_handler: bad signal %d"
msgstr "trap_handler: Falsches Signal %d."

#: variables.cc:358
#, c-format
msgid "error importing function definition for `%s'"
msgstr "Fehler beim Importieren der Funktionsdefinition für »%s«."

#: variables.cc:803
#, c-format
msgid "shell level (%d) too high, resetting to 1"
msgstr "Der Shell-Level (%d) ist zu hoch und wird auf 1 zurückgesetzt."

#: variables.cc:2523
msgid "make_local_variable: no function context at current scope"
msgstr "make_local_variable: no function context at current scope"

#: variables.cc:2543
#, c-format
msgid "%s: variable may not be assigned value"
msgstr "%s: Der Variable darf kein Wert zugewiesen werden."

#: variables.cc:2694 variables.cc:2748
#, c-format
msgid "%s: cannot inherit value from incompatible type"
msgstr ""

# Interner Fehler
#: variables.cc:3334
#, c-format
msgid "%s: assigning integer to name reference"
msgstr "%s: assigning integer to name reference"

# Interner Fehler
#: variables.cc:4170
msgid "all_local_variables: no function context at current scope"
msgstr "all_local_variables: no function context at current scope"

# Interner Fehler
#: variables.cc:4575
#, c-format
msgid "%s has null exportstr"
msgstr "%s has null exportstr"

# Interner Fehler
#: variables.cc:4580 variables.cc:4590
#, c-format
msgid "invalid character %d in exportstr for %s"
msgstr "invalid character %d in exportstr for %s"

# Interner Fehler
#: variables.cc:4597
#, c-format
msgid "no `=' in exportstr for %s"
msgstr "no `=' in exportstr for %s"

# Interner Fehler
#: variables.cc:5128
msgid "pop_var_context: head of shell_variables not a function context"
msgstr "pop_var_context: head of shell_variables not a function context"

# Interner Fehler
#: variables.cc:5141
msgid "pop_var_context: no global_variables context"
msgstr "pop_var_context: no global_variables context"

# Interner Fehler
#: variables.cc:5231
msgid "pop_scope: head of shell_variables not a temporary environment scope"
msgstr "pop_scope: head of shell_variables not a temporary environment scope"

# Interner Fehler
#: variables.cc:6190
#, c-format
msgid "%s: %s: cannot open as FILE"
msgstr "%s: %s: cannot open as FILE"

# Interner Fehler
#: variables.cc:6196
#, c-format
msgid "%s: %s: invalid value for trace file descriptor"
msgstr "%s: %s: invalid value for trace file descriptor"

# Interner Fehler
#: variables.cc:6241
#, c-format
msgid "%s: %s: compatibility value out of range"
msgstr "%s: %s: compatibility value out of range"

#: version.cc:54
#, fuzzy
msgid "Copyright (C) 2020 Free Software Foundation, Inc."
msgstr "Copyright (C) 2020 Free Software Foundation, Inc."

#: version.cc:56
msgid ""
"License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl."
"html>\n"
msgstr ""
"Lizenz GPLv3+: GNU GPL Version 3 oder jünger <http://gnu.org/licenses/gpl."
"html>\n"

#: version.cc:89
#, c-format
msgid "GNU bash, version %s (%s)\n"
msgstr "GNU bash, Version %s (%s)\n"

#: version.cc:95
msgid "This is free software; you are free to change and redistribute it."
msgstr "Dies ist freie Software. Sie darf verändert und verteilt werden."

#: version.cc:98
msgid "There is NO WARRANTY, to the extent permitted by law."
msgstr "Es wird keine Garantie gewährt, soweit das Gesetz es zulässt."

#, fuzzy, c-format
#~ msgid "%s: cannot assign"
#~ msgstr "%s: »unset« nicht möglich."

#, c-format
#~ msgid "%s: inlib failed"
#~ msgstr "%s: inlib gescheitert."

#, fuzzy, c-format
#~ msgid "%s: cannot execute: required file not found"
#~ msgstr "%s: Kann die Datei nicht ausführen."

#, c-format
#~ msgid "%s: expression error\n"
#~ msgstr "%s: Fehler im Ausdruck.\n"

#~ msgid "getcwd: cannot access parent directories"
#~ msgstr "getcwd: Kann auf die übergeordneten Verzeichnisse nicht zugreifen."

#, c-format
#~ msgid "malloc: failed assertion: %s\n"
#~ msgstr "malloc: Zusicherung gescheitert: %s.\n"

#, c-format
#~ msgid ""
#~ "\r\n"
#~ "malloc: %s:%d: assertion botched\r\n"
#~ msgstr ""
#~ "\r\n"
#~ "malloc: %s:%d: Zusicherung verpfuscht\\r\n"

#~ msgid "unknown"
#~ msgstr "Unbekannt"

#~ msgid "malloc: block on free list clobbered"
#~ msgstr ""
#~ "Malloc: Ein internet Speicherbereich (free list) wurde überschrieben."

#~ msgid "free: called with already freed block argument"
#~ msgstr "free: Wurde für bereits freigegebenen Speicherbereich aufgerufen."

#~ msgid "free: called with unallocated block argument"
#~ msgstr "free: Wurde für nicht zugeordneten Speicherbereich aufgerufen."

#~ msgid "free: underflow detected; mh_nbytes out of range"
#~ msgstr ""
#~ "free: Underflow erkannt; mh_nbytes außerhalb des Gültigkeitsbereichs."

#~ msgid "free: underflow detected; magic8 corrupted"
#~ msgstr "free: Underflow erkannt; magic8 beschädigt."

#~ msgid "free: start and end chunk sizes differ"
#~ msgstr "free: Beginn und Ende Segmentgrößen sind unterschiedlich."

#~ msgid "realloc: called with unallocated block argument"
#~ msgstr "realloc: Mit nicht zugewiesenen Argument aufgerufen."

#~ msgid "realloc: underflow detected; mh_nbytes out of range"
#~ msgstr ""
#~ "realloc: Underflow erkannt; mh_nbytes außerhalb des Gültigkeitsbereichs."

#~ msgid "realloc: underflow detected; magic8 corrupted"
#~ msgstr "realloc: Underflow erkannt; magic8 beschädigt."

#~ msgid "realloc: start and end chunk sizes differ"
#~ msgstr "realloc: Beginn und Ende Segmentgrößen sind unterschiedlich.<"

#, c-format
#~ msgid "register_alloc: alloc table is full with FIND_ALLOC?\n"
#~ msgstr ""
#~ "register_alloc: Speicherzuordnungstabelle ist mit FIND_ALLOC gefüllt?\n"

#, c-format
#~ msgid "register_alloc: %p already in table as allocated?\n"
#~ msgstr ""
#~ "register_alloc: %p ist bereits in der Speicherzuordnungstabelle als "
#~ "belegt gekennzeichnet?\n"

#, c-format
#~ msgid "register_free: %p already in table as free?\n"
#~ msgstr ""
#~ "register_free: %p ist bereits in der Speicherzuordnungstabelle als frei "
#~ "gekennzeichnet?\n"

#, c-format
#~ msgid "unexpected EOF while looking for matching `%c'"
#~ msgstr "Dateiende beim Suchen nach »%c« erreicht."

#~ msgid "unexpected EOF while looking for `]]'"
#~ msgstr "Dateiende beim Suchen nach »]]« erreicht."

#, c-format
#~ msgid "syntax error in conditional expression: unexpected token `%s'"
#~ msgstr "Syntaxfehler im bedingten Ausdruck: Unerwartetes Symbol »%s«."

#~ msgid "syntax error in conditional expression"
#~ msgstr "Syntaxfehler im bedingten Ausdruck."

#, c-format
#~ msgid "unexpected token `%s', expected `)'"
#~ msgstr "Unerwartetes Zeichen: »%s« anstatt von »)«"

#~ msgid "expected `)'"
#~ msgstr "»)« erwartet."

#, c-format
#~ msgid "syntax error near unexpected token `%s'"
#~ msgstr "Syntaxfehler beim unerwarteten Symbol »%s«"

#, c-format
#~ msgid "syntax error near `%s'"
#~ msgstr "Syntaxfehler bei »%s«"

#~ msgid "syntax error: unexpected end of file"
#~ msgstr "Syntaxfehler: Unerwartetes Dateiende."

#~ msgid "syntax error"
#~ msgstr "Syntaxfehler"

# Du oder Sie?
#, c-format
#~ msgid "Use \"%s\" to leave the shell.\n"
#~ msgstr "Verwenden Sie »%s«, um die Shell zu verlassen.\n"

#~ msgid "unexpected EOF while looking for matching `)'"
#~ msgstr "Dateiende beim Suchen nach zugehöriger »)« erreicht."

#~ msgid "I have no name!"
#~ msgstr "Ich habe keinen Benutzernamen!"

#, c-format
#~ msgid "%s: cannot allocate %lu bytes (%lu bytes allocated)"
#~ msgstr "%s: Konnte keine %lu Bytes reservieren (%lu bytes reserviert)."

#, c-format
#~ msgid "%s: cannot allocate %lu bytes"
#~ msgstr "%s: Konnte keine %lu Bytes reservieren."

#, c-format
#~ msgid "%s: %s:%d: cannot allocate %lu bytes (%lu bytes allocated)"
#~ msgstr ""
#~ "%s: %s:%d: Konnte keine %lu Bytes reservieren (%lu bytes reserviert)."

#, c-format
#~ msgid "%s: %s:%d: cannot allocate %lu bytes"
#~ msgstr "%s: %s:%d: Konnte keine %lu Bytes reservieren."

#~ msgid "alias [-p] [name[=value] ... ]"
#~ msgstr "alias [-p] [Name[=Wert] ... ]"

#~ msgid "unalias [-a] name [name ...]"
#~ msgstr "unalias [-a] Name [Name ...]"

#~ msgid ""
#~ "bind [-lpsvPSVX] [-m keymap] [-f filename] [-q name] [-u name] [-r "
#~ "keyseq] [-x keyseq:shell-command] [keyseq:readline-function or readline-"
#~ "command]"
#~ msgstr ""
#~ "bind [-lpsvPSVX] [-m Tastaturtabelle] [-f Dateiname] [-q Name] [-u Name]\n"
#~ "\t[-r Tastenfolge] [-x Tastenfolge:Shell Kommando]\n"
#~ "\t[Tastenfolge:readline-Funktion oder -Kommando]"

#~ msgid "break [n]"
#~ msgstr "break [n]"

#~ msgid "continue [n]"
#~ msgstr "continue [n]"

#~ msgid "builtin [shell-builtin [arg ...]]"
#~ msgstr "builtin [Shellkommando [Argument ...]]"

#~ msgid "caller [expr]"
#~ msgstr "caller [Ausdruck]"

#~ msgid "cd [-L|[-P [-e]] [-@]] [dir]"
#~ msgstr "cd [-L|[-P [-e]] [-@]] [Verzeichnis]"

#~ msgid "pwd [-LP]"
#~ msgstr "pwd [-LP]"

#~ msgid "command [-pVv] command [arg ...]"
#~ msgstr "command [-pVv] Kommando [Argument ...]"

#, fuzzy
#~ msgid ""
#~ "declare [-aAfFgiIlnrtux] [name[=value] ...] or declare -p [-aAfFilnrtux] "
#~ "[name ...]"
#~ msgstr "declare [-aAfFgiIlrntux] [-p] [Name[=Wert] ...]"

#
#, fuzzy
#~ msgid ""
#~ "typeset [-aAfFgiIlnrtux] name[=value] ... or typeset -p [-aAfFilnrtux] "
#~ "[name ...]"
#~ msgstr "typeset [-aAfFgiIlnrtux] [-p] Name[=Wert] ..."

#~ msgid "local [option] name[=value] ..."
#~ msgstr "local [Option] Name[=Wert] ..."

#~ msgid "echo [-neE] [arg ...]"
#~ msgstr "echo [-neE] [Argument ...]"

#~ msgid "echo [-n] [arg ...]"
#~ msgstr "echo [-n] [Argument ...]"

#~ msgid "enable [-a] [-dnps] [-f filename] [name ...]"
#~ msgstr "enable [-a] [-dnps] [-f Dateiname] [Name ...]"

#~ msgid "eval [arg ...]"
#~ msgstr "eval [Argument ...]"

# https://lists.gnu.org/archive/html/bug-bash/2019-09/msg00026.html
#~ msgid "getopts optstring name [arg ...]"
#~ msgstr "getopts Optionen [Argumente ...]"

# https://lists.gnu.org/archive/html/bug-bash/2019-09/msg00026.html
#~ msgid "exec [-cl] [-a name] [command [argument ...]] [redirection ...]"
#~ msgstr "exec [-cl] [-a Name] [Kommando [Argument ...]] [Umleitung ...]"

#~ msgid "exit [n]"
#~ msgstr "exit [n]"

#~ msgid "logout [n]"
#~ msgstr "logout [n]"

#~ msgid "fc [-e ename] [-lnr] [first] [last] or fc -s [pat=rep] [command]"
#~ msgstr ""
#~ "fc [-e Editor] [-lnr] [Anfang] [Ende] oder fc -s [Muster=Ersetzung] "
#~ "[Kommando]"

#~ msgid "fg [job_spec]"
#~ msgstr "fg [Jobbezeichnung]"

#~ msgid "bg [job_spec ...]"
#~ msgstr "bg [Jobbezeichnung ...]"

#~ msgid "hash [-lr] [-p pathname] [-dt] [name ...]"
#~ msgstr "hash [-lr] [-p Pfadname] [-dt] [Name ...]"

#~ msgid "help [-dms] [pattern ...]"
#~ msgstr "help [-dms] [Muster ...]"

#~ msgid ""
#~ "history [-c] [-d offset] [n] or history -anrw [filename] or history -ps "
#~ "arg [arg...]"
#~ msgstr ""
#~ "history [-c] [-d Offset] [n] oder history -anrw [Dateiname] oder history -"
#~ "ps Argument [Argument...]"

#~ msgid "jobs [-lnprs] [jobspec ...] or jobs -x command [args]"
#~ msgstr "jobs [-lnprs] [Jobbez. ...] or jobs -x Kommando [Arg]"

#~ msgid "disown [-h] [-ar] [jobspec ... | pid ...]"
#~ msgstr "disown [-h] [-ar] [Jobbezeichnung ... | pid ...]"

#~ msgid ""
#~ "kill [-s sigspec | -n signum | -sigspec] pid | jobspec ... or kill -l "
#~ "[sigspec]"
#~ msgstr ""
#~ "kill [-s Signalname | -n Signalnummer | -Signalname] pid | jobspec ... "
#~ "oder kill -l [Signalname]"

#~ msgid "let arg [arg ...]"
#~ msgstr "let Argument [Argument ...]"

#~ msgid ""
#~ "read [-ers] [-a array] [-d delim] [-i text] [-n nchars] [-N nchars] [-p "
#~ "prompt] [-t timeout] [-u fd] [name ...]"
#~ msgstr ""
#~ "read [-ers] [-a Feld] [-d Begrenzer] [-i Text] [-n Zeichenanzahl] [-N "
#~ "Zeichenanzahl] [-p Prompt] [-t Zeitlimit] [-u fd] [Name ...]"

#~ msgid "return [n]"
#~ msgstr "return [n]"

#, fuzzy
#~ msgid "set [-abefhkmnptuvxBCEHPT] [-o option-name] [--] [-] [arg ...]"
#~ msgstr "set [-abefhkmnptuvxBCHP] [-o Option] [--] [Argument ...]"

#~ msgid "unset [-f] [-v] [-n] [name ...]"
#~ msgstr "unset [-f] [-v] [-n] [NAME ...]"

#~ msgid "export [-fn] [name[=value] ...] or export -p"
#~ msgstr "export [-fn] [Name[=Wert] ...] oder export -p"

#~ msgid "readonly [-aAf] [name[=value] ...] or readonly -p"
#~ msgstr "readonly [-aAf] [Name[=Wert] ...] oder readonly -p"

#~ msgid "shift [n]"
#~ msgstr "shift [n]"

#~ msgid "source filename [arguments]"
#~ msgstr "source Dateiname [Argumente]"

#~ msgid ". filename [arguments]"
#~ msgstr ". Dateiname [Argumente]"

#~ msgid "suspend [-f]"
#~ msgstr "suspend [-f]"

#~ msgid "test [expr]"
#~ msgstr "test [Ausdruck]"

#~ msgid "[ arg... ]"
#~ msgstr "[ Argument... ]"

#~ msgid "trap [-lp] [[arg] signal_spec ...]"
#~ msgstr "trap [-lp] [[Argument] Signalbezeichnung ...]"

#~ msgid "type [-afptP] name [name ...]"
#~ msgstr "type [-afptP] Name [Name ...]"

#, fuzzy
#~ msgid "ulimit [-SHabcdefiklmnpqrstuvxPRT] [limit]"
#~ msgstr "ulimit [-SHabcdefiklmnpqrstuvxPT] [Grenze]"

#~ msgid "umask [-p] [-S] [mode]"
#~ msgstr "umask [-p] [-S] [Modus]"

#~ msgid "wait [-fn] [-p var] [id ...]"
#~ msgstr "wait [-fn] [-p Variable] [id ...]"

#~ msgid "wait [pid ...]"
#~ msgstr "wait [pid ...]"

#~ msgid "for NAME [in WORDS ... ] ; do COMMANDS; done"
#~ msgstr "for Name [in Wort ... ] ; do Kommandos; done"

#~ msgid "for (( exp1; exp2; exp3 )); do COMMANDS; done"
#~ msgstr "for (( Ausdr1; Ausdr2; Ausdr3 )); do Kommandos; done"

#~ msgid "select NAME [in WORDS ... ;] do COMMANDS; done"
#~ msgstr "select Name [in Wort ... ;] do Kommandos; done"

#~ msgid "time [-p] pipeline"
#~ msgstr "time [-p] Pipeline"

#~ msgid "case WORD in [PATTERN [| PATTERN]...) COMMANDS ;;]... esac"
#~ msgstr "case Wort in [Muster [| Muster]...) Kommandos ;;]... esac"

#~ msgid ""
#~ "if COMMANDS; then COMMANDS; [ elif COMMANDS; then COMMANDS; ]... [ else "
#~ "COMMANDS; ] fi"
#~ msgstr ""
#~ "if Kommandos; then Kommandos; [ elif Kommandos; then Kommandos; ]... "
#~ "[ else Kommandos; ] fi"

#, fuzzy
#~ msgid "while COMMANDS; do COMMANDS-2; done"
#~ msgstr "while Kommandos; do Kommandos; done"

#, fuzzy
#~ msgid "until COMMANDS; do COMMANDS-2; done"
#~ msgstr "until Kommandos; do Kommandos; done"

#~ msgid "coproc [NAME] command [redirections]"
#~ msgstr "coproc [Name] Kommando [Umleitungen]"

#~ msgid "function name { COMMANDS ; } or name () { COMMANDS ; }"
#~ msgstr "function Name { Kommandos ; } oder Name () { Kommandos ; }"

#~ msgid "{ COMMANDS ; }"
#~ msgstr "{ Kommandos ; }"

#~ msgid "job_spec [&]"
#~ msgstr "Jobbezeichnung [&]"

#~ msgid "(( expression ))"
#~ msgstr "(( Ausdruck ))"

#~ msgid "[[ expression ]]"
#~ msgstr "[[ Ausdruck ]]"

#~ msgid "variables - Names and meanings of some shell variables"
#~ msgstr "variables - Namen und Bedeutung einiger Shellvariablen"

#~ msgid "pushd [-n] [+N | -N | dir]"
#~ msgstr "pushd [-n] [+N | -N | Verzeichnis]"

#~ msgid "popd [-n] [+N | -N]"
#~ msgstr "popd [-n] [+N | -N]"

#~ msgid "dirs [-clpv] [+N] [-N]"
#~ msgstr "dirs [-clpv] [+N] [-N]"

#~ msgid "shopt [-pqsu] [-o] [optname ...]"
#~ msgstr "shopt [-pqsu] [-o] [Optionsname ...]"

#~ msgid "printf [-v var] format [arguments]"
#~ msgstr "printf [-v var] Format [Argumente]"

# https://lists.gnu.org/archive/html/bug-bash/2019-09/msg00027.html
#~ msgid ""
#~ "complete [-abcdefgjksuv] [-pr] [-DEI] [-o option] [-A action] [-G "
#~ "globpat] [-W wordlist] [-F function] [-C command] [-X filterpat] [-P "
#~ "prefix] [-S suffix] [name ...]"
#~ msgstr ""
#~ "complete [-abcdefgjksuv] [-pr] [-DEI] [-o Option] [-A Aktion] [-G "
#~ "Suchmuster] [-W Wortliste]  [-F Funktion] [-C Kommando] [-X Filtermuster] "
#~ "[-P Prefix] [-S Suffix] [Name \n"
#~ "...]"

# https://lists.gnu.org/archive/html/bug-bash/2019-09/msg00027.html
#~ msgid ""
#~ "compgen [-abcdefgjksuv] [-o option] [-A action] [-G globpat] [-W "
#~ "wordlist] [-F function] [-C command] [-X filterpat] [-P prefix] [-S "
#~ "suffix] [word]"
#~ msgstr ""
#~ "compgen [-abcdefgjksuv] [-o Option] [-A Aktion] [-G Suchmuster] [-W "
#~ "Wortliste] [-F Funktion] [-C Kommando] [-X Filtermuster] [-P Prefix] [-S "
#~ "Suffix] [Wort]"

#~ msgid "compopt [-o|+o option] [-DEI] [name ...]"
#~ msgstr "compopt [-o|+o Option] [-DEI] [Name ...]"

#~ msgid ""
#~ "mapfile [-d delim] [-n count] [-O origin] [-s count] [-t] [-u fd] [-C "
#~ "callback] [-c quantum] [array]"
#~ msgstr ""
#~ "mapfile [-d Begrenzer] [-n Anzahl] [-O Quelle] [-s Anzahl] [-t] [-u fd]\n"
#~ "        [-C Callback] [-c Menge] [Feldvariable]"

#~ msgid ""
#~ "readarray [-d delim] [-n count] [-O origin] [-s count] [-t] [-u fd] [-C "
#~ "callback] [-c quantum] [array]"
#~ msgstr ""
#~ "readarray [-d Begrenzer] [-n Anzahl] [-O Quelle] [-s Anzahl] [-t]\n"
#~ "          [-u fd] [-C Callback] [-c Menge] [Feldvariable]"

# alias
#~ msgid ""
#~ "Define or display aliases.\n"
#~ "    \n"
#~ "    Without arguments, `alias' prints the list of aliases in the "
#~ "reusable\n"
#~ "    form `alias NAME=VALUE' on standard output.\n"
#~ "    \n"
#~ "    Otherwise, an alias is defined for each NAME whose VALUE is given.\n"
#~ "    A trailing space in VALUE causes the next word to be checked for\n"
#~ "    alias substitution when the alias is expanded.\n"
#~ "    \n"
#~ "    Options:\n"
#~ "      -p\tprint all defined aliases in a reusable format\n"
#~ "    \n"
#~ "    Exit Status:\n"
#~ "    alias returns true unless a NAME is supplied for which no alias has "
#~ "been\n"
#~ "    defined."
#~ msgstr ""
#~ "Definiert Aliase oder zeigt sie an.\n"
#~ "\n"
#~ "    Ohne Argumente wird die Liste der Aliase (Synonyme) in der Form\n"
#~ "    »alias Name=Wert« auf die Standardausgabe ausgegeben.\n"
#~ "\n"
#~ "    Sonst wird ein Alias für jeden angegebenen Namen definiert, wenn\n"
#~ "    für diesen auch ein »Wert« angegeben wurde. Wenn »Wert« mit einem\n"
#~ "    Leerzeichen endet, dann wird auch das nächste Wort auf Aliase\n"
#~ "    überprüft.\n"
#~ "\n"
#~ "    Optionen:\n"
#~ "      -p\tGibt alle definierten Aliase aus.\n"
#~ "\n"
#~ "    Rückgabewert:\n"
#~ "    Meldet Erfolg, außer wenn ein »Name« angegeben worden ist, für den\n"
#~ "    kein Alias definiert wurde."

# unalias
#~ msgid ""
#~ "Remove each NAME from the list of defined aliases.\n"
#~ "    \n"
#~ "    Options:\n"
#~ "      -a\tremove all alias definitions\n"
#~ "    \n"
#~ "    Return success unless a NAME is not an existing alias."
#~ msgstr ""
#~ "Entfernt jeden angegebenen Namen von der Aliasliste.\n"
#~ "\n"
#~ "    Optionen:\n"
#~ "      -a\tEnfernt alle Alias-Definitionen.\n"
#~ "\n"
#~ "    Gibt immer Erfolg zurück, außer wenn der Alias nicht existiert."

# bind
#~ msgid ""
#~ "Set Readline key bindings and variables.\n"
#~ "    \n"
#~ "    Bind a key sequence to a Readline function or a macro, or set a\n"
#~ "    Readline variable.  The non-option argument syntax is equivalent to\n"
#~ "    that found in ~/.inputrc, but must be passed as a single argument:\n"
#~ "    e.g., bind '\"\\C-x\\C-r\": re-read-init-file'.\n"
#~ "    \n"
#~ "    Options:\n"
#~ "      -m  keymap         Use KEYMAP as the keymap for the duration of "
#~ "this\n"
#~ "                         command.  Acceptable keymap names are emacs,\n"
#~ "                         emacs-standard, emacs-meta, emacs-ctlx, vi, vi-"
#~ "move,\n"
#~ "                         vi-command, and vi-insert.\n"
#~ "      -l                 List names of functions.\n"
#~ "      -P                 List function names and bindings.\n"
#~ "      -p                 List functions and bindings in a form that can "
#~ "be\n"
#~ "                         reused as input.\n"
#~ "      -S                 List key sequences that invoke macros and their "
#~ "values\n"
#~ "      -s                 List key sequences that invoke macros and their "
#~ "values\n"
#~ "                         in a form that can be reused as input.\n"
#~ "      -V                 List variable names and values\n"
#~ "      -v                 List variable names and values in a form that "
#~ "can\n"
#~ "                         be reused as input.\n"
#~ "      -q  function-name  Query about which keys invoke the named "
#~ "function.\n"
#~ "      -u  function-name  Unbind all keys which are bound to the named "
#~ "function.\n"
#~ "      -r  keyseq         Remove the binding for KEYSEQ.\n"
#~ "      -f  filename       Read key bindings from FILENAME.\n"
#~ "      -x  keyseq:shell-command\tCause SHELL-COMMAND to be executed when\n"
#~ "    \t\t\t\tKEYSEQ is entered.\n"
#~ "      -X                 List key sequences bound with -x and associated "
#~ "commands\n"
#~ "                         in a form that can be reused as input.\n"
#~ "    \n"
#~ "    Exit Status:\n"
#~ "    bind returns 0 unless an unrecognized option is given or an error "
#~ "occurs."
#~ msgstr ""
#~ "Bestimmt Readline Tastenzuordnungen und Variablen.\n"
#~ "    \n"
#~ "    Weist eine Tastensequenz einer Readlinefunktion oder -makro zu\n"
#~ "    oder setzt eine Readlinevariable.  Die Argumentsyntax ist zu\n"
#~ "    den Einträgen in ~/.inputrc äquivalent, aber sie müssen als\n"
#~ "    einzelnes Argument übergeben werden.  Z.B: bind '\"\\C-x\\C-r\":\n"
#~ "    re-read-init-file'.\n"
#~ "    \n"
#~ "    Optionen:\n"
#~ "      -m  Keymap         Benutzt KEYMAP as Tastaturbelegung für die "
#~ "Laufzeit\n"
#~ "                         dieses Kommandos.  Gültige Keymapnamen sind: "
#~ "emacs,\n"
#~ "                         emacs-standard, emacs-meta, emacs-ctlx, vi, vi-"
#~ "move,\n"
#~ "                         vi-command und vi-insert.\n"
#~ "      -l                 Listet Funktionsnamen auf.\n"
#~ "      -P                 Listet Funktionsnamen und Tastenzuordnungen "
#~ "auf.\n"
#~ "      -p                 Listet Funktionsnamen und Tastenzuordnungen so "
#~ "auf,\n"
#~ "                         dass sie direkt als Eingabe verwendet werden "
#~ "können.\n"
#~ "      -S                 Listet Tastenfolgen und deren Werte auf, die "
#~ "Makros \n"
#~ "                         aufrufen.\n"
#~ "      -s                 Listet Tastenfolgen und deren Werte auf, die "
#~ "Makros \n"
#~ "                         aufrufen, dass sie als Eingabe wiederverwendet "
#~ "werden\n"
#~ "                         können.\n"
#~ "      -V                 Listet Variablennamen und Werte auf.\n"
#~ "      -v                 Listet Variablennamen und Werte so auf, dass sie "
#~ "als\n"
#~ "                         Eingabe verwendet werden können.\n"
#~ "      -q  Funktionsname  Sucht die Tastenfolgen, welche die angegebene\n"
#~ "                         Funktion aufrufen.\n"
#~ "      -u  Funktionsname  Entfernt alle der Funktion zugeordneten "
#~ "Tastenfolgen.\n"
#~ "      -r  Tastenfolge    Entfernt die Zuweisungen der angegebeben "
#~ "Tastenfolge.\n"
#~ "      -f  Dateiname      Liest die Tastenzuordnungen aus der angegebenen "
#~ "Datei.\n"
#~ "      -x  Tastenfolge:Shellkommando\tWeist der Tastenfolge das "
#~ "Shellkommando\n"
#~ "    \t\t\t\t\tzu.\n"
#~ "      -X                                Listet mit -x erzeugte\n"
#~ "                                        Tastenfolgen und deren Werte\n"
#~ "                                        auf, die Makros aufrufen, dass\n"
#~ "                                        sie als Eingabe wiederverwendet "
#~ "werden\n"
#~ "                                        können.\n"
#~ "    \n"
#~ "    Rückgabewert: \n"
#~ "    Bind gibt 0 zurück, wenn keine unerkannte Option angegeben wurde\n"
#~ "    oder ein Fehler eintrat."

# break
#~ msgid ""
#~ "Exit for, while, or until loops.\n"
#~ "    \n"
#~ "    Exit a FOR, WHILE or UNTIL loop.  If N is specified, break N "
#~ "enclosing\n"
#~ "    loops.\n"
#~ "    \n"
#~ "    Exit Status:\n"
#~ "    The exit status is 0 unless N is not greater than or equal to 1."
#~ msgstr ""
#~ "Verlässt for-, while- oder until-Schleifen.\n"
#~ "\n"
#~ "    Break beendet eine »for«-, »while«- oder »until«- Schleife. Wenn »n«\n"
#~ "    angegeben ist, werden entsprechend viele geschachtelte Schleifen "
#~ "beendet.\n"
#~ "\n"
#~ "    Rückgabewert:\n"
#~ "    Der Rückgabewert ist 0, außer »n« ist nicht größer oder gleich 1."

# continue
#~ msgid ""
#~ "Resume for, while, or until loops.\n"
#~ "    \n"
#~ "    Resumes the next iteration of the enclosing FOR, WHILE or UNTIL "
#~ "loop.\n"
#~ "    If N is specified, resumes the Nth enclosing loop.\n"
#~ "    \n"
#~ "    Exit Status:\n"
#~ "    The exit status is 0 unless N is not greater than or equal to 1."
#~ msgstr ""
#~ "Springt zum Schleifenanfang von for, while, oder until Schleifen.\n"
#~ "\n"
#~ "    Springt zum Schleifenanfang der aktuellen »for«, »while« oder "
#~ "»until«\n"
#~ "    Schleife. Wenn »n« angegeben ist, wird zum Beginn der »n«-ten\n"
#~ "    übergeordneten Schleife gesprungen.\n"
#~ "\n"
#~ "    Rückgabewert:\n"
#~ "    Der Rückgabewert ist 0, außer wenn »n« nicht größer oder gleich 1 ist."

# builtin
#~ msgid ""
#~ "Execute shell builtins.\n"
#~ "    \n"
#~ "    Execute SHELL-BUILTIN with arguments ARGs without performing command\n"
#~ "    lookup.  This is useful when you wish to reimplement a shell builtin\n"
#~ "    as a shell function, but need to execute the builtin within the "
#~ "function.\n"
#~ "    \n"
#~ "    Exit Status:\n"
#~ "    Returns the exit status of SHELL-BUILTIN, or false if SHELL-BUILTIN "
#~ "is\n"
#~ "    not a shell builtin."
#~ msgstr ""
#~ "Führt ein in der Shell definiertes Kommando aus.\n"
#~ "\n"
#~ "    Führt ein in der Shell definiertes Kommando ohne vorherige\n"
#~ "    Befehlssuche aus. Dies ist dann nützlich, wenn das Kommando als\n"
#~ "    Shell-Funktion reimplementiert werden soll, aber das Kommando\n"
#~ "    innerhalb der neuen Funktion aufgerufen wird.\n"
#~ "\n"
#~ "    Rückgabewert: \n"
#~ "    Der Rückgabewert des aufgerufenen Kommandos oder »falsch«, wenn\n"
#~ "    dieses nicht existiert."

# caller
#~ msgid ""
#~ "Return the context of the current subroutine call.\n"
#~ "    \n"
#~ "    Without EXPR, returns \"$line $filename\".  With EXPR, returns\n"
#~ "    \"$line $subroutine $filename\"; this extra information can be used "
#~ "to\n"
#~ "    provide a stack trace.\n"
#~ "    \n"
#~ "    The value of EXPR indicates how many call frames to go back before "
#~ "the\n"
#~ "    current one; the top frame is frame 0.\n"
#~ "    \n"
#~ "    Exit Status:\n"
#~ "    Returns 0 unless the shell is not executing a shell function or EXPR\n"
#~ "    is invalid."
#~ msgstr ""
#~ "Gibt Informationen zum aktuellen Subroutinenaufruf aus.\n"
#~ "\n"
#~ "    Ohne Argument wird die Zeilennummer und der Dateiname angezeigt. Mit\n"
#~ "    Argument werden Zeilennummer, Subroutinenname und Dateiname "
#~ "ausgegeben.\n"
#~ "    Mit diesen Informationen kann ein Stacktrace erzeugt werden.\n"
#~ "\n"
#~ "    Das Argument gibt die angezeigte Position im Funktionsaufrufstapel "
#~ "an,\n"
#~ "    wobei 0 der aktuelle Funktionsaufruf ist.\n"
#~ "\n"
#~ "    Rückgabewert:\n"
#~ "    Ist ungleich 0 wenn keine Shellfunktion ausgeführt wird oder das "
#~ "Argument\n"
#~ "    ungültig ist, sonst 0."

# cd
#~ msgid ""
#~ "Change the shell working directory.\n"
#~ "    \n"
#~ "    Change the current directory to DIR.  The default DIR is the value of "
#~ "the\n"
#~ "    HOME shell variable.\n"
#~ "    \n"
#~ "    The variable CDPATH defines the search path for the directory "
#~ "containing\n"
#~ "    DIR.  Alternative directory names in CDPATH are separated by a colon "
#~ "(:).\n"
#~ "    A null directory name is the same as the current directory.  If DIR "
#~ "begins\n"
#~ "    with a slash (/), then CDPATH is not used.\n"
#~ "    \n"
#~ "    If the directory is not found, and the shell option `cdable_vars' is "
#~ "set,\n"
#~ "    the word is assumed to be  a variable name.  If that variable has a "
#~ "value,\n"
#~ "    its value is used for DIR.\n"
#~ "    \n"
#~ "    Options:\n"
#~ "      -L\tforce symbolic links to be followed: resolve symbolic\n"
#~ "    \t\tlinks in DIR after processing instances of `..'\n"
#~ "      -P\tuse the physical directory structure without following\n"
#~ "    \t\tsymbolic links: resolve symbolic links in DIR before\n"
#~ "    \t\tprocessing instances of `..'\n"
#~ "      -e\tif the -P option is supplied, and the current working\n"
#~ "    \t\tdirectory cannot be determined successfully, exit with\n"
#~ "    \t\ta non-zero status\n"
#~ "      -@\ton systems that support it, present a file with extended\n"
#~ "    \t\tattributes as a directory containing the file attributes\n"
#~ "    \n"
#~ "    The default is to follow symbolic links, as if `-L' were specified.\n"
#~ "    `..' is processed by removing the immediately previous pathname "
#~ "component\n"
#~ "    back to a slash or the beginning of DIR.\n"
#~ "    \n"
#~ "    Exit Status:\n"
#~ "    Returns 0 if the directory is changed, and if $PWD is set "
#~ "successfully when\n"
#~ "    -P is used; non-zero otherwise."
#~ msgstr ""
#~ "Wechselt das Arbeitsverzeichnis.\n"
#~ "\n"
#~ "    Wechselt in das angegebene Arbeitsverzeichnis. Ohne Angabe eines\n"
#~ "    Verzeichnisses wird in das in der Variable HOME definierte\n"
#~ "    Verzeichnis gewechselt.\n"
#~ "\n"
#~ "    Die Variable CDPATH definiert den Suchpfad, in dem nach dem\n"
#~ "    angegebenen Verzeichnisnamen gesucht wird. Mehrere Pfade werden\n"
#~ "    durch Doppelpunkte »:« getrennt. Ein leerer Pfadname entspricht\n"
#~ "    dem aktuellen Verzeichnis. Mit einem vollständigen Pfadnamen wird\n"
#~ "    CDPATH nicht benutzt.\n"
#~ "\n"
#~ "    Wird kein entsprechendes Verzeichnis gefunden und die Shelloption\n"
#~ "    »cdable_vars« ist gesetzt, dann wird der `Wert' als Variable\n"
#~ "    interpretiert. Dessen Inhalt wird dann als Verzeichnisname\n"
#~ "    verwendet.\n"
#~ "\n"
#~ "    Optionen:\n"
#~ "      -L        Erzwingt, dass symbolischen Links gefolgt wird.\n"
#~ "                Symbolische Links im aktuellen Verzeichnis werden nach\n"
#~ "                dem übergeordneten Verzeichnis aufgelöst.\n"
#~ "      -P        Symbolische Links werden ignoriert. Symbolische\n"
#~ "                Links im aktuellen Verzeichnis werden vor dem\n"
#~ "                übergeordneten Verzeichnis aufgelöst.\n"
#~ "      -e        Wenn mit der Option »-P« das aktuelle Arbeitsverzeichnis\n"
#~ "                nicht ermittelt werden kann, wird mit einem Rückgabewert\n"
#~ "                ungleich 0 abgebrochen.\n"
#~ "      -@        Wenn es das System unterstützt, wird eine Datei mit\n"
#~ "                erweiterten Attributen als ein Verzeichnis angezeigt,\n"
#~ "                welches die erweiterten Attribute enthält.\n"
#~ "\n"
#~ "    Standardmäßig wird symbolischen Links gefolgt (Option -L).\n"
#~ "    Das übergeordnete Verzeichnis wird ermittelt, indem der\n"
#~ "    Dateiname am letzten Schrägstrich gekürzt wird, oder es wird der\n"
#~ "    Anfang von DIR verwendet.\n"
#~ "\n"
#~ "    Rückgabewert:\n"
#~ "    Der Rückgabewert ist 0, wenn das Verzeichnis erfolgreich\n"
#~ "    gewechselt wurde, oder wenn die Option -P angegeben und $PWD\n"
#~ "    erfolgreich gesetzt werden konnte. Sonst ist er ungleich 0."

# pwd
#~ msgid ""
#~ "Print the name of the current working directory.\n"
#~ "    \n"
#~ "    Options:\n"
#~ "      -L\tprint the value of $PWD if it names the current working\n"
#~ "    \t\tdirectory\n"
#~ "      -P\tprint the physical directory, without any symbolic links\n"
#~ "    \n"
#~ "    By default, `pwd' behaves as if `-L' were specified.\n"
#~ "    \n"
#~ "    Exit Status:\n"
#~ "    Returns 0 unless an invalid option is given or the current directory\n"
#~ "    cannot be read."
#~ msgstr ""
#~ "Gibt den Namen des aktuellen Arbeitsverzeichnisses aus.\n"
#~ "\n"
#~ "    Optionen:\n"
#~ "      -L        Gibt den Inhalt der Variable $PWD aus, wenn sie das "
#~ "aktuelle\n"
#~ "                Arbeitsverzeichnis enthält.\n"
#~ "      -P        Gibt den physischen Verzeichnispfad aus, ohne "
#~ "symbolische\n"
#~ "                Links.\n"
#~ "\n"
#~ "    Standardmäßig wird immer die Option »-L« gesetzt.\n"
#~ "\n"
#~ "    Rückgabewert:\n"
#~ "    Ist 0, außer wenn eine ungültige Option angegeben oder das aktuelle\n"
#~ "    Verzeichnis nicht lesbar ist."

# colon
#~ msgid ""
#~ "Null command.\n"
#~ "    \n"
#~ "    No effect; the command does nothing.\n"
#~ "    \n"
#~ "    Exit Status:\n"
#~ "    Always succeeds."
#~ msgstr ""
#~ "Leeranweisung.\n"
#~ "\n"
#~ "    Leeranweisung; das Kommando hat keine Wirkung.\n"
#~ "\n"
#~ "    Rückgabewert:\n"
#~ "    Das Kommando ist immer »wahr«."

# true
#~ msgid ""
#~ "Return a successful result.\n"
#~ "    \n"
#~ "    Exit Status:\n"
#~ "    Always succeeds."
#~ msgstr ""
#~ "Gibt »wahr« zurück.\n"
#~ "    \n"
#~ "    Rückgabewert:\n"
#~ "    Immer »wahr«."

#~ msgid ""
#~ "Return an unsuccessful result.\n"
#~ "    \n"
#~ "    Exit Status:\n"
#~ "    Always fails."
#~ msgstr ""
#~ "Gibt »falsch« zurück.\n"
#~ "    \n"
#~ "    Rückgabewert:\n"
#~ "    Immer »falsch«."

# command
#~ msgid ""
#~ "Execute a simple command or display information about commands.\n"
#~ "    \n"
#~ "    Runs COMMAND with ARGS suppressing  shell function lookup, or "
#~ "display\n"
#~ "    information about the specified COMMANDs.  Can be used to invoke "
#~ "commands\n"
#~ "    on disk when a function with the same name exists.\n"
#~ "    \n"
#~ "    Options:\n"
#~ "      -p    use a default value for PATH that is guaranteed to find all "
#~ "of\n"
#~ "            the standard utilities\n"
#~ "      -v    print a description of COMMAND similar to the `type' builtin\n"
#~ "      -V    print a more verbose description of each COMMAND\n"
#~ "    \n"
#~ "    Exit Status:\n"
#~ "    Returns exit status of COMMAND, or failure if COMMAND is not found."
#~ msgstr ""
#~ "Führt ein einfaches Kommando aus oder zeigt Informationen über Kommandos "
#~ "an.\n"
#~ "\n"
#~ "    Führt das Kommando mit den angegebenen Argumenten aus, ohne\n"
#~ "    Shell-Funktion nachzuschlagen oder zeigt Informationen über die\n"
#~ "    Kommandos an. Dadurch können auch dann Kommandos ausgeführt\n"
#~ "    werden, wenn eine Shell-Funktion gleichen Namens existiert.\n"
#~ "\n"
#~ "    Optionen:\n"
#~ "      -p        Es wird ein Standardwert für PATH verwendet, der "
#~ "garantiert,\n"
#~ "                dass alle Standard-Dienstprogramme gefunden werden.\n"
#~ "      -v        Beschreibung des Kommandos ausgeben.\n"
#~ "                Ähnlich dem eingebauten Kommando »type«.\n"
#~ "      -V        Eine ausführlichere Beschreibung jedes Kommandos "
#~ "ausgeben.\n"
#~ "\n"
#~ "    Rückgabewert:\n"
#~ "    Gibt den Rückgabewert des Kommandos zurück, oder eine Fehlermeldung, "
#~ "wenn\n"
#~ "    das Kommando nicht gefunden wird."

# declare
#~ msgid ""
#~ "Set variable values and attributes.\n"
#~ "    \n"
#~ "    Declare variables and give them attributes.  If no NAMEs are given,\n"
#~ "    display the attributes and values of all variables.\n"
#~ "    \n"
#~ "    Options:\n"
#~ "      -f\trestrict action or display to function names and definitions\n"
#~ "      -F\trestrict display to function names only (plus line number and\n"
#~ "    \t\tsource file when debugging)\n"
#~ "      -g\tcreate global variables when used in a shell function; "
#~ "otherwise\n"
#~ "    \t\tignored\n"
#~ "      -I\tif creating a local variable, inherit the attributes and value\n"
#~ "    \t\tof a variable with the same name at a previous scope\n"
#~ "      -p\tdisplay the attributes and value of each NAME\n"
#~ "    \n"
#~ "    Options which set attributes:\n"
#~ "      -a\tto make NAMEs indexed arrays (if supported)\n"
#~ "      -A\tto make NAMEs associative arrays (if supported)\n"
#~ "      -i\tto make NAMEs have the `integer' attribute\n"
#~ "      -l\tto convert the value of each NAME to lower case on assignment\n"
#~ "      -n\tmake NAME a reference to the variable named by its value\n"
#~ "      -r\tto make NAMEs readonly\n"
#~ "      -t\tto make NAMEs have the `trace' attribute\n"
#~ "      -u\tto convert the value of each NAME to upper case on assignment\n"
#~ "      -x\tto make NAMEs export\n"
#~ "    \n"
#~ "    Using `+' instead of `-' turns off the given attribute.\n"
#~ "    \n"
#~ "    Variables with the integer attribute have arithmetic evaluation (see\n"
#~ "    the `let' command) performed when the variable is assigned a value.\n"
#~ "    \n"
#~ "    When used in a function, `declare' makes NAMEs local, as with the "
#~ "`local'\n"
#~ "    command.  The `-g' option suppresses this behavior.\n"
#~ "    \n"
#~ "    Exit Status:\n"
#~ "    Returns success unless an invalid option is supplied or a variable\n"
#~ "    assignment error occurs."
#~ msgstr ""
#~ "Setzt Variablenwerte und deren Attribute.\n"
#~ "\n"
#~ "    Deklariert Variablen und weist ihnen Attribute zu. Wenn keine Namen\n"
#~ "    angegeben sind, werden die Attribute und Werte aller Variablen "
#~ "ausgegeben.\n"
#~ "    \n"
#~ "    Optionen:\n"
#~ "      -f        Schränkt Aktionen oder Anzeigen auf Funktionsnamen\n"
#~ "                und Definitionen ein.\n"
#~ "      -F        Zeigt nur Funktionsnamen an (inklusive Zeilennummer\n"
#~ "                und Quelldatei beim Debuggen).\n"
#~ "      -g        Deklariert globale Varieblen innerhalb einer\n"
#~ "                Shellfunktion; wird ansonsten ignoriert.\n"
#~ "      -I        Eine neue lokale Variable erhält die Attribute und Werte "
#~ "der\n"
#~ "                Variable mit gleichen Namen im vorherigen "
#~ "Gültigkeitsbereich. \n"
#~ "      -p        Zeigt die Attribute und Werte jeder angegebenen\n"
#~ "                Variable an.\n"
#~ "\n"
#~ "    Attribute setzen:\n"
#~ "      -a\tDeklariert ein indiziertes Feld (wenn unterstützt).\n"
#~ "      -A\tDeklariert ein assoziatives Feld (wenn unterstützt).\n"
#~ "      -i\tDeklariert eine ganzzahlige Variable.\n"
#~ "      -l\tKonvertiert die übergebenen Werte zu Kleinbuchstaben.\n"
#~ "      -n\tDer Name wird als Variable interpretiert. \n"
#~ "      -r\tDeklariert nur lesbare Variablen.\n"
#~ "      -t\tWeist das Attribut »trace« zu.\n"
#~ "      -u\tKonvertiert die übergebenen Werte in Großbuchstaben.\n"
#~ "      -x\tExportiert die Variablen.\n"
#~ "\n"
#~ "    Das Voranstellen von »+« anstelle von »-« schaltet die angegebenen\n"
#~ "    Attribute ab.\n"
#~ "\n"
#~ "    Für ganzzahlige Variablen werden bei der Zuweisung arithmetische\n"
#~ "    Berechnungen durchgeführt (siehe »help let«).\n"
#~ "\n"
#~ "    Innerhalb einer Funktion werden lokale Variablen erzeugt. Die\n"
#~ "    Option »-g« unterdrückt dieses Verhalten.\n"
#~ "\n"
#~ "    Rückgabewert:\n"
#~ "    Gibt »Erfolg« zurück, außer eine ungültige Option wurde angegeben,\n"
#~ "    oder ein Fehler trat auf."

#~ msgid ""
#~ "Set variable values and attributes.\n"
#~ "    \n"
#~ "    A synonym for `declare'.  See `help declare'."
#~ msgstr ""
#~ "Setzt Variablen Werte und Eigenschaften\n"
#~ "\n"
#~ "    Synonym für »declare«. Siehe »help declare«."

#~ msgid ""
#~ "Define local variables.\n"
#~ "    \n"
#~ "    Create a local variable called NAME, and give it VALUE.  OPTION can\n"
#~ "    be any option accepted by `declare'.\n"
#~ "    \n"
#~ "    Local variables can only be used within a function; they are visible\n"
#~ "    only to the function where they are defined and its children.\n"
#~ "    \n"
#~ "    Exit Status:\n"
#~ "    Returns success unless an invalid option is supplied, a variable\n"
#~ "    assignment error occurs, or the shell is not executing a function."
#~ msgstr ""
#~ "Definiert lokale Variablen.\n"
#~ "\n"
#~ "    Erzeugt eine lokale Variable Name und weist ihr den Wert Wert zu.\n"
#~ "    Option kann eine beliebige von »declare« akzeptierte Option sein.\n"
#~ "\n"
#~ "    Lokale Variablen können nur innerhalb einer Funktion benutzt\n"
#~ "    werden. Sie sind nur in der sie erzeugenden Funktion und ihren\n"
#~ "    Kindern sichtbar.\n"
#~ "\n"
#~ "    Rückgabewert: \n"
#~ "    Liefert 0 außer bei Angabe einer ungültigen Option, einer\n"
#~ "    fehlerhaften Variablenzuweisung oder dem Aufruf außerhalb einer\n"
#~ "    Funktion."

# echo
#~ msgid ""
#~ "Write arguments to the standard output.\n"
#~ "    \n"
#~ "    Display the ARGs, separated by a single space character and followed "
#~ "by a\n"
#~ "    newline, on the standard output.\n"
#~ "    \n"
#~ "    Options:\n"
#~ "      -n\tdo not append a newline\n"
#~ "      -e\tenable interpretation of the following backslash escapes\n"
#~ "      -E\texplicitly suppress interpretation of backslash escapes\n"
#~ "    \n"
#~ "    `echo' interprets the following backslash-escaped characters:\n"
#~ "      \\a\talert (bell)\n"
#~ "      \\b\tbackspace\n"
#~ "      \\c\tsuppress further output\n"
#~ "      \\e\tescape character\n"
#~ "      \\E\tescape character\n"
#~ "      \\f\tform feed\n"
#~ "      \\n\tnew line\n"
#~ "      \\r\tcarriage return\n"
#~ "      \\t\thorizontal tab\n"
#~ "      \\v\tvertical tab\n"
#~ "      \\\\\tbackslash\n"
#~ "      \\0nnn\tthe character whose ASCII code is NNN (octal).  NNN can be\n"
#~ "    \t\t0 to 3 octal digits\n"
#~ "      \\xHH\tthe eight-bit character whose value is HH (hexadecimal).  "
#~ "HH\n"
#~ "    \t\tcan be one or two hex digits\n"
#~ "      \\uHHHH\tthe Unicode character whose value is the hexadecimal value "
#~ "HHHH.\n"
#~ "    \t\tHHHH can be one to four hex digits.\n"
#~ "      \\UHHHHHHHH the Unicode character whose value is the hexadecimal "
#~ "value\n"
#~ "    \t\tHHHHHHHH. HHHHHHHH can be one to eight hex digits.\n"
#~ "    \n"
#~ "    Exit Status:\n"
#~ "    Returns success unless a write error occurs."
#~ msgstr ""
#~ "Ausgabe der Argumente auf die Standardausgabe.\n"
#~ "\n"
#~ "    Zeigt die Argumente auf der Standardausgabe gefolgt von einem\n"
#~ "    Zeilenumbruch an.\n"
#~ "\n"
#~ "    Optionen:\n"
#~ "      -n\tKeinen Zeilenumbruch anfügen\n"
#~ "      -e\tInterpretation der folgenden Escape-Sequenzen zulassen\n"
#~ "      -E\tKeine Interpretation der Escape-Sequenzen.\n"
#~ "\n"
#~ "    »echo« interpretiert die folgenden Escape-Sequenzen:\n"
#~ "      \a\tAlarm (Glocke)\n"
#~ "      \\b\tRücktaste (Backspace)\n"
#~ "      \\c\tweitere Ausgabe unterdrücken\n"
#~ "      \\e\tEscape-Zeichen\n"
#~ "      \\E\tEscape-Zeichen\n"
#~ "      \\f\tSeitenvorschub\n"
#~ "      \\n\tZeilenvorschub\n"
#~ "      \\r\tWagenrücklauf\n"
#~ "      \\t\tHorizontaler Tabulator\n"
#~ "      \\v\tVertikaler Tabulator\n"
#~ "      \\\\tumgekehrter Schrägstrich (Backslash)\n"
#~ "      \\0nnn\tZeichen mit dem ASCII-Code »NNN« (oktal). »NNN« kann null\n"
#~ "    \t\tbis drei oktale Ziffern haben.\n"
#~ "      \\xHH\tAcht-Bit-Zeichen mit dem Wert »HH« (hexadezimal). »HH«\n"
#~ "    \t\tkann eine oder zwei hexadezimale Ziffern haben.\n"
#~ "\n"
#~ "    Rückgabewert:\n"
#~ "    Gibt »Erfolg« zurück, außer ein Ausgabefehler tritt auf."

#~ msgid ""
#~ "Write arguments to the standard output.\n"
#~ "    \n"
#~ "    Display the ARGs on the standard output followed by a newline.\n"
#~ "    \n"
#~ "    Options:\n"
#~ "      -n\tdo not append a newline\n"
#~ "    \n"
#~ "    Exit Status:\n"
#~ "    Returns success unless a write error occurs."
#~ msgstr ""
#~ "Ausgabe der Argumente auf die Standardausgabe.\n"
#~ "\n"
#~ "    Zeigt die Argumente auf der Standardausgabe an, gefolgt von einem\n"
#~ "    Zeilenumbruch.\n"
#~ "\n"
#~ "    Option:\n"
#~ "      -n\tkeinen Zeilenumbruch anfügen.\n"
#~ "\n"
#~ "    Rückgabewert:\n"
#~ "    Gibt »Erfolg« zurück, außer nach einem Schreibfehler."

# enable
#~ msgid ""
#~ "Enable and disable shell builtins.\n"
#~ "    \n"
#~ "    Enables and disables builtin shell commands.  Disabling allows you "
#~ "to\n"
#~ "    execute a disk command which has the same name as a shell builtin\n"
#~ "    without using a full pathname.\n"
#~ "    \n"
#~ "    Options:\n"
#~ "      -a\tprint a list of builtins showing whether or not each is "
#~ "enabled\n"
#~ "      -n\tdisable each NAME or display a list of disabled builtins\n"
#~ "      -p\tprint the list of builtins in a reusable format\n"
#~ "      -s\tprint only the names of Posix `special' builtins\n"
#~ "    \n"
#~ "    Options controlling dynamic loading:\n"
#~ "      -f\tLoad builtin NAME from shared object FILENAME\n"
#~ "      -d\tRemove a builtin loaded with -f\n"
#~ "    \n"
#~ "    Without options, each NAME is enabled.\n"
#~ "    \n"
#~ "    To use the `test' found in $PATH instead of the shell builtin\n"
#~ "    version, type `enable -n test'.\n"
#~ "    \n"
#~ "    Exit Status:\n"
#~ "    Returns success unless NAME is not a shell builtin or an error occurs."
#~ msgstr ""
#~ "Eingebaute Shell-Kommandos aktivieren und deaktivieren.\n"
#~ "\n"
#~ "    Aktiviert und deaktiviert eingebaute Shell-Kommandos. Die "
#~ "Deaktivierung\n"
#~ "    erlaubt Ihnen, eigene Kommandos mit demselben Namen wie die "
#~ "eingebauten\n"
#~ "    Kommandos zu nutzen, ohne den kompletten Pfad angeben zu müssen.\n"
#~ "\n"
#~ "    Optionen:\n"
#~ "      -a\tGibt eine Liste der eingebauten Kommandos aus inklusive der\n"
#~ "        \tInformation, ob sie aktiv sind oder nicht.\n"
#~ "\n"
#~ "      -n\tdeaktiviert jedes angegebene Kommando oder gibt eine\n"
#~ "        \tListe der deaktivierten eingebauten Kommandos aus.\n"
#~ "      -p\tGibt eine Liste der eingebauten Kommandos in einem\n"
#~ "        \twiederverwendbaren Format aus.\n"
#~ "      -s\tGibt nur die Namen der »speziellen« in POSIX eingebauten\n"
#~ "        \tKommandos aus.\n"
#~ "\n"
#~ "    Optionen zum Beeinflussen des dynamischen Ladens:\n"
#~ "      -f\tLädt ein eingebautes Kommando aus der angegebenen Datei.\n"
#~ "      -d\tEntfernt ein mit »-f« geladenes Kommando.\n"
#~ "\n"
#~ "    Ohne Optionen wird jedes angegebene Kommando aktiviert.\n"
#~ "\n"
#~ "    Um das unter $PATH liegende Kommando »test« anstelle der eingebauten\n"
#~ "    Version zu nutzen, geben Sie »enable -n test« ein.\n"
#~ "\n"
#~ "    Rückgabewert:\n"
#~ "    Gibt »Erfolg« zurück, außer Name ist kein eingebautes Kommando\n"
#~ "    oder ein Fehler tritt auf."

#~ msgid ""
#~ "Execute arguments as a shell command.\n"
#~ "    \n"
#~ "    Combine ARGs into a single string, use the result as input to the "
#~ "shell,\n"
#~ "    and execute the resulting commands.\n"
#~ "    \n"
#~ "    Exit Status:\n"
#~ "    Returns exit status of command or success if command is null."
#~ msgstr ""
#~ "Führt die Argumente als Shellkommando aus.\n"
#~ "\n"
#~ "    Fügt die Argumente zu einer Zeichenkette zusammen und verwendet\n"
#~ "    das Ergebnis als Eingebe in eine Shell, welche die enthaltenen\n"
#~ "    Kommandos ausführt.\n"
#~ "\n"
#~ "    Rückgabewert:\n"
#~ "    Der Status des Kommandos oder Erfolg, wenn das Kommando leer war."

# getopts
#~ msgid ""
#~ "Parse option arguments.\n"
#~ "    \n"
#~ "    Getopts is used by shell procedures to parse positional parameters\n"
#~ "    as options.\n"
#~ "    \n"
#~ "    OPTSTRING contains the option letters to be recognized; if a letter\n"
#~ "    is followed by a colon, the option is expected to have an argument,\n"
#~ "    which should be separated from it by white space.\n"
#~ "    \n"
#~ "    Each time it is invoked, getopts will place the next option in the\n"
#~ "    shell variable $name, initializing name if it does not exist, and\n"
#~ "    the index of the next argument to be processed into the shell\n"
#~ "    variable OPTIND.  OPTIND is initialized to 1 each time the shell or\n"
#~ "    a shell script is invoked.  When an option requires an argument,\n"
#~ "    getopts places that argument into the shell variable OPTARG.\n"
#~ "    \n"
#~ "    getopts reports errors in one of two ways.  If the first character\n"
#~ "    of OPTSTRING is a colon, getopts uses silent error reporting.  In\n"
#~ "    this mode, no error messages are printed.  If an invalid option is\n"
#~ "    seen, getopts places the option character found into OPTARG.  If a\n"
#~ "    required argument is not found, getopts places a ':' into NAME and\n"
#~ "    sets OPTARG to the option character found.  If getopts is not in\n"
#~ "    silent mode, and an invalid option is seen, getopts places '?' into\n"
#~ "    NAME and unsets OPTARG.  If a required argument is not found, a '?'\n"
#~ "    is placed in NAME, OPTARG is unset, and a diagnostic message is\n"
#~ "    printed.\n"
#~ "    \n"
#~ "    If the shell variable OPTERR has the value 0, getopts disables the\n"
#~ "    printing of error messages, even if the first character of\n"
#~ "    OPTSTRING is not a colon.  OPTERR has the value 1 by default.\n"
#~ "    \n"
#~ "    Getopts normally parses the positional parameters, but if arguments\n"
#~ "    are supplied as ARG values, they are parsed instead.\n"
#~ "    \n"
#~ "    Exit Status:\n"
#~ "    Returns success if an option is found; fails if the end of options "
#~ "is\n"
#~ "    encountered or an error occurs."
#~ msgstr ""
#~ "Verarbeitet Optionsargumente.\n"
#~ "\n"
#~ "    Getopts wird von Shellprozeduren verwendet, um die\n"
#~ "    Kommandozeilenoptionen auszuwerten.\n"
#~ "\n"
#~ "    \"Optionen\" enthält die auszuwertenden Buchstaben. Ein Doppelpunkt\n"
#~ "    nach dem Buchstaben zeigt an, dass ein Argument erwartet wird,\n"
#~ "    welches durch ein Leerzeichen von der Option getrennt ist.\n"
#~ "\n"
#~ "    Bei jedem Aufruf von »getopts« wird die nächste Option der\n"
#~ "    $Variable zugewiesen. Diese wird angelegt, falls sie noch\n"
#~ "    nicht existiert. Weiterhin wird der Index des nächsten zu\n"
#~ "    verarbeitenden Arguments der Shell-Variablen OPTIND\n"
#~ "    zugewiesen. OPTIND wird bei jedem Aufruf einer Shell oder eines\n"
#~ "    Shell-Skripts mit 1 initialisiert. Wenn eine Option ein Argument\n"
#~ "    benötigt, wird dieses OPTARG zugewiesen.\n"
#~ "\n"
#~ "    Für Fehlermeldungen gibt es zwei Varianten. Wenn das erste\n"
#~ "    Zeichen des Optionsstrings ein Doppelpunkt ist, wird der stille\n"
#~ "    Fehlermodus von »getopts« verwendet. In diesem Modus wird keine\n"
#~ "    Fehlermeldung ausgegeben. Wenn eine ungültige Option erkannt wird,\n"
#~ "    wird das gefundene Optionenzeichen OPTARG zugewiesen. Wenn ein\n"
#~ "    benötigtes Argument fehlt, wird ein »:« der Variable zugewiesen\n"
#~ "    und OPTARG auf das gefundene Optionenzeichen gesetzt. Im anderen\n"
#~ "    Fehlermodus wird ein »?« der Variable zugewiesen, OPTARG geleert\n"
#~ "    und eine Fehlermeldung ausgegeben.\n"
#~ "\n"
#~ "    Wenn die Shell-Variable OPTERR den Wert »0« hat, werden durch "
#~ "getopts\n"
#~ "    keine Fehlermeldungen ausgegeben, auch wenn das erste Zeichen\n"
#~ "    von OPTSTRING kein Doppelpunkt ist. OPTERR hat den Vorgabewert »1«.\n"
#~ "\n"
#~ "    Wenn im Aufruf von »getops« die »Argumente« angegeben sind, werden "
#~ "diese\n"
#~ "    verarbeitet. Ansonsten werden die von der Position abhängigen\n"
#~ "    Parameter ($1, $2, etc.) verarbeitet.\n"
#~ "\n"
#~ "    Rückgabewert:\n"
#~ "    Gibt »Erfolg« zurück wenn eine Option gefunden wird und\n"
#~ "    »gescheitert«, wenn das Ende der Optionen erreicht oder ein Fehler\n"
#~ "    aufgetreten ist."

# exec
#~ msgid ""
#~ "Replace the shell with the given command.\n"
#~ "    \n"
#~ "    Execute COMMAND, replacing this shell with the specified program.\n"
#~ "    ARGUMENTS become the arguments to COMMAND.  If COMMAND is not "
#~ "specified,\n"
#~ "    any redirections take effect in the current shell.\n"
#~ "    \n"
#~ "    Options:\n"
#~ "      -a name\tpass NAME as the zeroth argument to COMMAND\n"
#~ "      -c\texecute COMMAND with an empty environment\n"
#~ "      -l\tplace a dash in the zeroth argument to COMMAND\n"
#~ "    \n"
#~ "    If the command cannot be executed, a non-interactive shell exits, "
#~ "unless\n"
#~ "    the shell option `execfail' is set.\n"
#~ "    \n"
#~ "    Exit Status:\n"
#~ "    Returns success unless COMMAND is not found or a redirection error "
#~ "occurs."
#~ msgstr ""
#~ "Ersetzt die Shell durch das angegebene Kommando.\n"
#~ "\n"
#~ "    Führt das angegebene Kommando einschließlich dessen Optionen an\n"
#~ "    Stelle der Shell aus. Wenn kein Kommando angegeben ist, wirken\n"
#~ "    alle Weiterleitungen für die aktuellen Shell.\n"
#~ "\n"
#~ "    Optionen:\n"
#~ "      -a Name\tSetzt den Namen als nulltes Argument für das Kommando.\n"
#~ "      -c\tFührt das Kommando in einer leeren Umgebung aus.\n"
#~ "      -l\tSetzt einen Strich in das nullte Argument für das Kommando.\n"
#~ "\n"
#~ "    Wenn das Kommando nicht ausgeführt werden kann, wird eine nicht\n"
#~ "    interaktive Shell beendet, außer die Shell-Option »execfail« ist\n"
#~ "    gesetzt.\n"
#~ "\n"
#~ "    Rückgabewert:\n"
#~ "    Gibt »Erfolg« zurück, außer das Kommando wurde nicht gefunden oder\n"
#~ "    ein Weiterleitungsfehler trat auf."

# exit
#~ msgid ""
#~ "Exit the shell.\n"
#~ "    \n"
#~ "    Exits the shell with a status of N.  If N is omitted, the exit "
#~ "status\n"
#~ "    is that of the last command executed."
#~ msgstr ""
#~ "Beendet die aktuelle Shell.\n"
#~ "\n"
#~ "    Beendet die aktuelle Shell mit dem Rückgabewert N. Wenn N nicht "
#~ "angegeben\n"
#~ "    ist, wird der Rückgabewert des letzten ausgeführten Kommandos "
#~ "übernommen."

# logout
#~ msgid ""
#~ "Exit a login shell.\n"
#~ "    \n"
#~ "    Exits a login shell with exit status N.  Returns an error if not "
#~ "executed\n"
#~ "    in a login shell."
#~ msgstr ""
#~ "Beendet eine Login-Shell.\n"
#~ "\n"
#~ "    Beendet eine Login-Shell mit dem Rückgabewert »n«. Wenn logout\n"
#~ "    nicht von einer Login-Shell aus ausgeführt wurde, wird ein Fehler\n"
#~ "    zurückgegeben."

# fc
#~ msgid ""
#~ "Display or execute commands from the history list.\n"
#~ "    \n"
#~ "    fc is used to list or edit and re-execute commands from the history "
#~ "list.\n"
#~ "    FIRST and LAST can be numbers specifying the range, or FIRST can be "
#~ "a\n"
#~ "    string, which means the most recent command beginning with that\n"
#~ "    string.\n"
#~ "    \n"
#~ "    Options:\n"
#~ "      -e ENAME\tselect which editor to use.  Default is FCEDIT, then "
#~ "EDITOR,\n"
#~ "    \t\tthen vi\n"
#~ "      -l \tlist lines instead of editing\n"
#~ "      -n\tomit line numbers when listing\n"
#~ "      -r\treverse the order of the lines (newest listed first)\n"
#~ "    \n"
#~ "    With the `fc -s [pat=rep ...] [command]' format, COMMAND is\n"
#~ "    re-executed after the substitution OLD=NEW is performed.\n"
#~ "    \n"
#~ "    A useful alias to use with this is r='fc -s', so that typing `r cc'\n"
#~ "    runs the last command beginning with `cc' and typing `r' re-executes\n"
#~ "    the last command.\n"
#~ "    \n"
#~ "    Exit Status:\n"
#~ "    Returns success or status of executed command; non-zero if an error "
#~ "occurs."
#~ msgstr ""
#~ "Anzeigen oder Ausführen von Befehlen aus der History-Liste.\n"
#~ "    \n"
#~ "    fc wird verwendet, um Befehle aus der History-Liste aufzulisten,\n"
#~ "    zu bearbeiten und erneut auszuführen.  FIRST und LAST können\n"
#~ "    Zahlen sein, die den Bereich angeben, oder FIRST kann eine\n"
#~ "    Zeichenkette sein, was bedeutet, dass der jüngste Befehl mit\n"
#~ "    dieser Zeichenfolge beginnt.\n"
#~ "    \n"
#~ "    Optionen:\n"
#~ "      -e ENAME Auswahl des zu verwendenden Editors.  Standard sind "
#~ "FCEDIT,\n"
#~ "         dann EDITOR, dann vi.\n"
#~ "      -l Zeilen auflisten statt bearbeiten.\n"
#~ "      -n Zeilennummern beim Auflisten weglassen.\n"
#~ "      -r kehrt die Reihenfolge der Zeilen um (die neuesten Zeilen "
#~ "zuerst).\n"
#~ "    \n"
#~ "    Mit `fc -s [pat=rep ...] [command]' wird COMMAND erneut\n"
#~ "    ausgeführt, nachdem die Ersetzung OLD=NEW durchgeführt wurde.\n"
#~ "    \n"
#~ "    Ein nützlicher Alias ist r='fc -s', so dass die Eingabe von `r cc'\n"
#~ "    den letzten Befehl ausführt, der mit \"cc\" beginnt, und die Eingabe\n"
#~ "    von \"r\" den letzten Befehl erneut ausführt.\n"
#~ "    \n"
#~ "    Exit-Status:\n"
#~ "    Gibt den Erfolg oder den Status des ausgeführten Befehls zurück;\n"
#~ "    ungleich Null, wenn ein Fehler auftritt."

#~ msgid ""
#~ "Move job to the foreground.\n"
#~ "    \n"
#~ "    Place the job identified by JOB_SPEC in the foreground, making it "
#~ "the\n"
#~ "    current job.  If JOB_SPEC is not present, the shell's notion of the\n"
#~ "    current job is used.\n"
#~ "    \n"
#~ "    Exit Status:\n"
#~ "    Status of command placed in foreground, or failure if an error occurs."
#~ msgstr ""
#~ "Bringt einen Job in den Vordergrund.\n"
#~ "\n"
#~ "    Bringt den mit JOB_SPEC bezeichneten Prozess als aktuellen Job in "
#~ "den\n"
#~ "    Vordergrund. Wenn JOB_SPEC nicht angegeben ist, wird der zuletzt\n"
#~ "    angehaltene Job verwendet.\n"
#~ "\n"
#~ "    Rückgabewert:\n"
#~ "    Status des in den Vordergrund geholten Jobs oder Fehler."

#~ msgid ""
#~ "Move jobs to the background.\n"
#~ "    \n"
#~ "    Place the jobs identified by each JOB_SPEC in the background, as if "
#~ "they\n"
#~ "    had been started with `&'.  If JOB_SPEC is not present, the shell's "
#~ "notion\n"
#~ "    of the current job is used.\n"
#~ "    \n"
#~ "    Exit Status:\n"
#~ "    Returns success unless job control is not enabled or an error occurs."
#~ msgstr ""
#~ "Bringt einen Job in den Hintergrund.\n"
#~ "\n"
#~ "    Bringt den mit JOB_SPEC bezeichneten Job in den Hintergrund,\n"
#~ "    als ob er mit »&« gestartet wurde.\n"
#~ "\n"
#~ "    Rückgabewert:\n"
#~ "    Immer Erfolg, außer wenn die Jobsteuerung nicht verfügbar ist\n"
#~ "    oder ein Fehler auftritt."

# hash
#~ msgid ""
#~ "Remember or display program locations.\n"
#~ "    \n"
#~ "    Determine and remember the full pathname of each command NAME.  If\n"
#~ "    no arguments are given, information about remembered commands is "
#~ "displayed.\n"
#~ "    \n"
#~ "    Options:\n"
#~ "      -d\tforget the remembered location of each NAME\n"
#~ "      -l\tdisplay in a format that may be reused as input\n"
#~ "      -p pathname\tuse PATHNAME as the full pathname of NAME\n"
#~ "      -r\tforget all remembered locations\n"
#~ "      -t\tprint the remembered location of each NAME, preceding\n"
#~ "    \t\teach location with the corresponding NAME if multiple\n"
#~ "    \t\tNAMEs are given\n"
#~ "    Arguments:\n"
#~ "      NAME\tEach NAME is searched for in $PATH and added to the list\n"
#~ "    \t\tof remembered commands.\n"
#~ "    \n"
#~ "    Exit Status:\n"
#~ "    Returns success unless NAME is not found or an invalid option is "
#~ "given."
#~ msgstr ""
#~ "Programpfade merken oder anzeigen.\n"
#~ "    \n"
#~ "    Ermittelt und speichert den vollständigen Pfadnamen jedes\n"
#~ "    Kommandos NAME.  Wenn keine Argumente angegeben werden, werden\n"
#~ "    Informationen über gespeicherte Kommandod angezeigt.\n"
#~ "    \n"
#~ "    Optionen:\n"
#~ "      -d Vergessen des Speicherortes für jeden NAME\n"
#~ "      -l Anzeige in einem Format, das als Eingabe wiederverwendet werden "
#~ "kann\n"
#~ "      -p Pfadname verwendet PATHNAME als den vollständigen Pfadnamen von "
#~ "NAME\n"
#~ "      -r vergisst alle gespeicherten Pfade\n"
#~ "      \n"
#~ "      -t gibt den Speicherort jedes NAMENS aus, wobei jedem\n"
#~ "         Speicherort der entsprechende NAME vorangestellt wird,\n"
#~ "         wenn mehrere NAMEs angegeben sind\n"
#~ "                \n"
#~ "    Argumente:\n"
#~ "        NAME    Jeder NAME wird in $PATH gesucht und in die Liste\n"
#~ "        der gespeicherten Befehle hinzugefügt.\n"
#~ "    \n"
#~ "    Exit-Status:\n"
#~ "    Gibt Erfolg zurück, es sei denn, NAME wird nicht gefunden oder es\n"
#~ "    wird eine ungültige Option angegeben."

# help
#~ msgid ""
#~ "Display information about builtin commands.\n"
#~ "    \n"
#~ "    Displays brief summaries of builtin commands.  If PATTERN is\n"
#~ "    specified, gives detailed help on all commands matching PATTERN,\n"
#~ "    otherwise the list of help topics is printed.\n"
#~ "    \n"
#~ "    Options:\n"
#~ "      -d\toutput short description for each topic\n"
#~ "      -m\tdisplay usage in pseudo-manpage format\n"
#~ "      -s\toutput only a short usage synopsis for each topic matching\n"
#~ "    \t\tPATTERN\n"
#~ "    \n"
#~ "    Arguments:\n"
#~ "      PATTERN\tPattern specifying a help topic\n"
#~ "    \n"
#~ "    Exit Status:\n"
#~ "    Returns success unless PATTERN is not found or an invalid option is "
#~ "given."
#~ msgstr ""
#~ "Informationen zu eingebauten Kommandos.\n"
#~ "\n"
#~ "    Zeigt kurze Informationen zu eingebauten Kommandos an. Wenn ein\n"
#~ "    Muster angegeben ist, dann wird eine ausführliche Anleitung zu\n"
#~ "    allen Kommandos mit zutreffendem Muster angezeigt. Sonst wird die\n"
#~ "    Liste der Hilfethemen ausgegeben.\n"
#~ "\n"
#~ "    Optionen:\n"
#~ "      -d\tKurzbeschreibung für jedes Thema\n"
#~ "      -m\tAnzeige im Manpage-Format.\n"
#~ "      -s\tGibt eine kurze Zusammenfassung für jedes angegebene\n"
#~ "        \tangegebene Thema aus\n"
#~ "\n"
#~ "    Argumente:\n"
#~ "      Muster\tDas gesuchte Hilfetheme\n"
#~ "\n"
#~ "    Rückgabestatus:\n"
#~ "    Erfolg, außer wenn das Muster nicht gefunden oder eine ungültige "
#~ "Option\n"
#~ "    angegeben wurde."

# history
#~ msgid ""
#~ "Display or manipulate the history list.\n"
#~ "    \n"
#~ "    Display the history list with line numbers, prefixing each modified\n"
#~ "    entry with a `*'.  An argument of N lists only the last N entries.\n"
#~ "    \n"
#~ "    Options:\n"
#~ "      -c\tclear the history list by deleting all of the entries\n"
#~ "      -d offset\tdelete the history entry at position OFFSET. Negative\n"
#~ "    \t\toffsets count back from the end of the history list\n"
#~ "    \n"
#~ "      -a\tappend history lines from this session to the history file\n"
#~ "      -n\tread all history lines not already read from the history file\n"
#~ "    \t\tand append them to the history list\n"
#~ "      -r\tread the history file and append the contents to the history\n"
#~ "    \t\tlist\n"
#~ "      -w\twrite the current history to the history file\n"
#~ "    \n"
#~ "      -p\tperform history expansion on each ARG and display the result\n"
#~ "    \t\twithout storing it in the history list\n"
#~ "      -s\tappend the ARGs to the history list as a single entry\n"
#~ "    \n"
#~ "    If FILENAME is given, it is used as the history file.  Otherwise,\n"
#~ "    if HISTFILE has a value, that is used, else ~/.bash_history.\n"
#~ "    \n"
#~ "    If the HISTTIMEFORMAT variable is set and not null, its value is "
#~ "used\n"
#~ "    as a format string for strftime(3) to print the time stamp "
#~ "associated\n"
#~ "    with each displayed history entry.  No time stamps are printed "
#~ "otherwise.\n"
#~ "    \n"
#~ "    Exit Status:\n"
#~ "    Returns success unless an invalid option is given or an error occurs."
#~ msgstr ""
#~ "Zeigt die Verlaufsliste an oder bearbeitet sie.\n"
#~ "    \n"
#~ "    Zeigt die Verlaufsliste mit Zeilennummern an und stellt jedem\n"
#~ "    geänderten Eintrag ein `*' vorangestellt.  Ein Argument von N\n"
#~ "    listet nur die letzten N Einträge auf.\n"
#~ "    \n"
#~ "    Optionen:\n"
#~ "      -c Löscht die Verlaufsliste, indem alle Einträge gelöscht werden.\n"
#~ "      -d offset löscht den Verlaufseintrag an der Position\n"
#~ "         OFFSET. Negative Offsets zählen vom Verlaufslistenende\n"
#~ "         zurück.\n"
#~ "      -a Anhängen vom Verlauf dieser Sitzung an die Verlaufsdatei.\n"
#~ "      -n alle nicht bereits aus der Verlaufsdatei gelesenen.\n"
#~ "         Verlaufszeilen lesen und an die Verlaufsliste anhängen.\n"
#~ "      -r liest die Verlaufsdatei und hängt den Inhalt an die\n"
#~ "         Verlaufsliste an.\n"
#~ "      -w schreibt den aktuellen Verlauf in die Verlaufsdatei.\n"
#~ "      -p führt eine Verlaufserweiterung für jedes ARG durch und zeigt\n"
#~ "         das Ergebnis an, ohne es in der Verlaufslise einzutragen.\n"
#~ "      -s die ARGs als einen einzigen Eintrag an die History-Liste "
#~ "anhängen.\n"
#~ "    \n"
#~ "    Wenn FILENAME angegeben ist, wird dieser als History-Datei "
#~ "verwendet.\n"
#~ "    Andernfalls, wenn HISTFILE einen Wert hat, wird dieser verwendet,\n"
#~ "    sonst ~/.bash_history.\n"
#~ "    \n"
#~ "    Wenn die Variable HISTTIMEFORMAT gesetzt und nicht null ist, wird\n"
#~ "    ihr Wert verwendet als Formatierungszeichenfolge für strftime(3)\n"
#~ "    verwendet, um den Zeitstempel zu Zeitstempel für jeden angezeigten\n"
#~ "    History-Eintrag zu drucken.  Andernfalls werden keine Zeitstempel\n"
#~ "    gedruckt.\n"
#~ "    \n"
#~ "    Rückgabewert:\n"
#~ "    Gibt einen Erfolg zurück, es sei denn, es wurde eine ungültige\n"
#~ "    Option angegeben oder es ist ein Fehler aufgetreten."

# jobs
#~ msgid ""
#~ "Display status of jobs.\n"
#~ "    \n"
#~ "    Lists the active jobs.  JOBSPEC restricts output to that job.\n"
#~ "    Without options, the status of all active jobs is displayed.\n"
#~ "    \n"
#~ "    Options:\n"
#~ "      -l\tlists process IDs in addition to the normal information\n"
#~ "      -n\tlists only processes that have changed status since the last\n"
#~ "    \t\tnotification\n"
#~ "      -p\tlists process IDs only\n"
#~ "      -r\trestrict output to running jobs\n"
#~ "      -s\trestrict output to stopped jobs\n"
#~ "    \n"
#~ "    If -x is supplied, COMMAND is run after all job specifications that\n"
#~ "    appear in ARGS have been replaced with the process ID of that job's\n"
#~ "    process group leader.\n"
#~ "    \n"
#~ "    Exit Status:\n"
#~ "    Returns success unless an invalid option is given or an error "
#~ "occurs.\n"
#~ "    If -x is used, returns the exit status of COMMAND."
#~ msgstr ""
#~ "Auftragstatus anzeigen.\n"
#~ "    \n"
#~ "    Listet die aktiven Aufträge auf.  JOBSPEC schränkt die Ausgabe auf\n"
#~ "    diesen Auftrag ein.  Ohne Optionen werden die Status der aktiven\n"
#~ "    Aufträge angezeigt.\n"
#~ "    \n"
#~ "    Optionen:\n"
#~ "      -l zeigt zusätzlich auch die Prozessnummern an.\n"
#~ "      -n zeigt nur die Prozesse an, deren Status sich seit der letzten\n"
#~ "         Benachrichtigung geändert haben.\n"
#~ "      -p zeigt nur Prozessnummern an.\n"
#~ "      -r zeigt nur laufende Aufträge an.\n"
#~ "      -s zeigt nur gestoppte Aufträge an\n"
#~ "    \n"
#~ "    Mit der Option -x wird COMMAND ausgeführt, nachdem alle in ARGS\n"
#~ "    enthaltenen Auftragsspezifikationen durch die zugehörigen\n"
#~ "    Prozesnummern ersetzt worden sind.\n"
#~ "    \n"
#~ "    Rückgabewert:\n"
#~ "    Gibt einen Erfolg zurück, es sei denn, es wurde eine ungültige\n"
#~ "    Option angegeben oder es ist ein Fehler aufgetreten.  Wenn -x\n"
#~ "    verwendet wird, wird der Rückgebewert von COMMAND zurückgegeben."

# disown
#~ msgid ""
#~ "Remove jobs from current shell.\n"
#~ "    \n"
#~ "    Removes each JOBSPEC argument from the table of active jobs.  "
#~ "Without\n"
#~ "    any JOBSPECs, the shell uses its notion of the current job.\n"
#~ "    \n"
#~ "    Options:\n"
#~ "      -a\tremove all jobs if JOBSPEC is not supplied\n"
#~ "      -h\tmark each JOBSPEC so that SIGHUP is not sent to the job if the\n"
#~ "    \t\tshell receives a SIGHUP\n"
#~ "      -r\tremove only running jobs\n"
#~ "    \n"
#~ "    Exit Status:\n"
#~ "    Returns success unless an invalid option or JOBSPEC is given."
#~ msgstr ""
#~ "Entfernt Aufträge aus der aktuellen Shell.\n"
#~ "    \n"
#~ "    Entfernt jedes JOBSPEC-Argument aus der Tabelle der aktiven\n"
#~ "    Aufträge. Ohne JOBSPECs verwendet die Shell ihre Vorstellung vom\n"
#~ "    aktuellen Auftrag.\n"
#~ "    \n"
#~ "    Optionen:\n"
#~ "      -a entfernt alle Aufträge, wenn JOBSPEC nicht angegeben wird.\n"
#~ "      -h JOBSPEC maskieren, so dass der Auftrag kein SIGHUP erhält,\n"
#~ "         wenn die Shell ein SIGHUP empfängt.\n"
#~ "      -r entfernt nur laufende Aufträge.\n"
#~ "    \n"
#~ "    Beenden Status:\n"
#~ "    Gibt Erfolg zurück, außer wenn eine ungültige Option oder\n"
#~ "    JOBSPEC angegeben wurde."

# kill
#~ msgid ""
#~ "Send a signal to a job.\n"
#~ "    \n"
#~ "    Send the processes identified by PID or JOBSPEC the signal named by\n"
#~ "    SIGSPEC or SIGNUM.  If neither SIGSPEC nor SIGNUM is present, then\n"
#~ "    SIGTERM is assumed.\n"
#~ "    \n"
#~ "    Options:\n"
#~ "      -s sig\tSIG is a signal name\n"
#~ "      -n sig\tSIG is a signal number\n"
#~ "      -l\tlist the signal names; if arguments follow `-l' they are\n"
#~ "    \t\tassumed to be signal numbers for which names should be listed\n"
#~ "      -L\tsynonym for -l\n"
#~ "    \n"
#~ "    Kill is a shell builtin for two reasons: it allows job IDs to be "
#~ "used\n"
#~ "    instead of process IDs, and allows processes to be killed if the "
#~ "limit\n"
#~ "    on processes that you can create is reached.\n"
#~ "    \n"
#~ "    Exit Status:\n"
#~ "    Returns success unless an invalid option is given or an error occurs."
#~ msgstr ""
#~ "Sendet ein Signal an einen Auftrag.\n"
#~ "    \n"
#~ "    Sendet den durch PID oder JOBSPEC identifizierten Prozessen das\n"
#~ "    mit SIGSPEC oder SIGNUM anggebene Signal. Wenn weder SIGSPEC\n"
#~ "    noch SIGNUM angegeben sind, dann wird wird SIGTERM gesendet.\n"
#~ "    \n"
#~ "    Optionen:\n"
#~ "      -s sig SIG ist ein Signalname.\n"
#~ "      -n sig SIG ist eine Signalnummer.\n"
#~ "      -l listet die Signalnamen auf. Wenn Argumente auf `-l' folgen,\n"
#~ "         werden für diese Signalnummern die Namen aufgelistet.\n"
#~ "      -L Synonym für -l.\n"
#~ "    \n"
#~ "    Kill ist ein in die Shell eingebaute Funktion, da diese erlaubt,\n"
#~ "    Auftrags- statt Prozessnummern anzugeben. Weierhin kann Kill\n"
#~ "    Prozesse auch dann beenden, wenn die maximal erlaubte\n"
#~ "    Prozessanzahl erreicht ist.\n"
#~ "    \n"
#~ "    Exit-Status:\n"
#~ "    Gibt Erfolg zurück, es sei denn, es wurde eine ungültige Option\n"
#~ "    angegeben oder es ist ein Fehler aufgetreten."

#~ msgid ""
#~ "Evaluate arithmetic expressions.\n"
#~ "    \n"
#~ "    Evaluate each ARG as an arithmetic expression.  Evaluation is done "
#~ "in\n"
#~ "    fixed-width integers with no check for overflow, though division by "
#~ "0\n"
#~ "    is trapped and flagged as an error.  The following list of operators "
#~ "is\n"
#~ "    grouped into levels of equal-precedence operators.  The levels are "
#~ "listed\n"
#~ "    in order of decreasing precedence.\n"
#~ "    \n"
#~ "    \tid++, id--\tvariable post-increment, post-decrement\n"
#~ "    \t++id, --id\tvariable pre-increment, pre-decrement\n"
#~ "    \t-, +\t\tunary minus, plus\n"
#~ "    \t!, ~\t\tlogical and bitwise negation\n"
#~ "    \t**\t\texponentiation\n"
#~ "    \t*, /, %\t\tmultiplication, division, remainder\n"
#~ "    \t+, -\t\taddition, subtraction\n"
#~ "    \t<<, >>\t\tleft and right bitwise shifts\n"
#~ "    \t<=, >=, <, >\tcomparison\n"
#~ "    \t==, !=\t\tequality, inequality\n"
#~ "    \t&\t\tbitwise AND\n"
#~ "    \t^\t\tbitwise XOR\n"
#~ "    \t|\t\tbitwise OR\n"
#~ "    \t&&\t\tlogical AND\n"
#~ "    \t||\t\tlogical OR\n"
#~ "    \texpr ? expr : expr\n"
#~ "    \t\t\tconditional operator\n"
#~ "    \t=, *=, /=, %=,\n"
#~ "    \t+=, -=, <<=, >>=,\n"
#~ "    \t&=, ^=, |=\tassignment\n"
#~ "    \n"
#~ "    Shell variables are allowed as operands.  The name of the variable\n"
#~ "    is replaced by its value (coerced to a fixed-width integer) within\n"
#~ "    an expression.  The variable need not have its integer attribute\n"
#~ "    turned on to be used in an expression.\n"
#~ "    \n"
#~ "    Operators are evaluated in order of precedence.  Sub-expressions in\n"
#~ "    parentheses are evaluated first and may override the precedence\n"
#~ "    rules above.\n"
#~ "    \n"
#~ "    Exit Status:\n"
#~ "    If the last ARG evaluates to 0, let returns 1; let returns 0 "
#~ "otherwise."
#~ msgstr ""
#~ "Auswerten arithmetischer Ausdrücke.\n"
#~ "    \n"
#~ "    Jedes ARG wird als arithmetischer Ausdruck ausgewertet.  Die\n"
#~ "    Auswertung erfolgt in Ganzzahlen mit fester Breite ohne\n"
#~ "    Überprüfung auf Überlauf. Division durch 0 wird abgefangen und als\n"
#~ "    Fehler gekennzeichnet.  Die folgende Liste von Operatoren ist in\n"
#~ "    abnehmender Präferenz nach gleichrangigen Operatoren gruppiert.\n"
#~ "    \n"
#~ "    \tid++, id-- Variable post-increment, post-decrement\n"
#~ "    \t++id, --id Variable pre-increment, pre-decrement\n"
#~ "    \t-, + unäres Minus, Plus\n"
#~ "    \t!, ~ logische und bitweise Negation\n"
#~ "    \t** Potenzierung\n"
#~ "    \t*, /, % Multiplikation, Division, Rest\n"
#~ "    \t+, - Addition, Subtraktion\n"
#~ "    \t<<, >> bitweise Links- und Rechtsverschiebung\n"
#~ "    \t<=, >=, <, > Vergleich\n"
#~ "    \t==, != Gleichheit, Ungleichheit\n"
#~ "    \t& bitweises UND\n"
#~ "    \t^ bitweises XOR\n"
#~ "    \t| bitweises ODER\n"
#~ "    \t&& logisches UND\n"
#~ "    \t|| logisches OR\n"
#~ "    \texpr ? expr : expr\n"
#~ "               Bedingte Ausführung\n"
#~ "    \t=, *=, /=, %=,\n"
#~ "    \t+=, -=, <<=, >>=,\n"
#~ "    \t&=, ^=, |= Zuweisung\n"
#~ "    \n"
#~ "    Shell-Variablen sind als Operanden zulässig. Der Variablenname\n"
#~ "    wird innerhalb eines Ausdrucks durch seinen Wert (der in eine\n"
#~ "    Ganzzahl mit fester Breite umgewandelt wird) ersetzt.  Das\n"
#~ "    Integer-Attribut der Variablen muss nicht eingeschaltet sein, um\n"
#~ "    in einem Ausdruck verwendet zu werden.\n"
#~ "    \n"
#~ "    Die Operatoren werden in der Reihenfolge ihres Vorrangs\n"
#~ "    ausgewertet. Unterausdrücke in Klammern werden zuerst ausgewertet\n"
#~ "    und können die obigen Rangfolge Regeln außer Kraft setzen.\n"
#~ "    \n"
#~ "    Rückgabewert:\n"
#~ "    Wenn der letzte ARG 0 ergibt, gibt let 1 zurück; andernfalls gibt let "
#~ "0 zurück."

# read
#, fuzzy
#~ msgid ""
#~ "Read a line from the standard input and split it into fields.\n"
#~ "    \n"
#~ "    Reads a single line from the standard input, or from file descriptor "
#~ "FD\n"
#~ "    if the -u option is supplied.  The line is split into fields as with "
#~ "word\n"
#~ "    splitting, and the first word is assigned to the first NAME, the "
#~ "second\n"
#~ "    word to the second NAME, and so on, with any leftover words assigned "
#~ "to\n"
#~ "    the last NAME.  Only the characters found in $IFS are recognized as "
#~ "word\n"
#~ "    delimiters. By default, the backslash character escapes delimiter "
#~ "characters\n"
#~ "    and newline.\n"
#~ "    \n"
#~ "    If no NAMEs are supplied, the line read is stored in the REPLY "
#~ "variable.\n"
#~ "    \n"
#~ "    Options:\n"
#~ "      -a array\tassign the words read to sequential indices of the array\n"
#~ "    \t\tvariable ARRAY, starting at zero\n"
#~ "      -d delim\tcontinue until the first character of DELIM is read, "
#~ "rather\n"
#~ "    \t\tthan newline\n"
#~ "      -e\tuse Readline to obtain the line\n"
#~ "      -i text\tuse TEXT as the initial text for Readline\n"
#~ "      -n nchars\treturn after reading NCHARS characters rather than "
#~ "waiting\n"
#~ "    \t\tfor a newline, but honor a delimiter if fewer than\n"
#~ "    \t\tNCHARS characters are read before the delimiter\n"
#~ "      -N nchars\treturn only after reading exactly NCHARS characters, "
#~ "unless\n"
#~ "    \t\tEOF is encountered or read times out, ignoring any\n"
#~ "    \t\tdelimiter\n"
#~ "      -p prompt\toutput the string PROMPT without a trailing newline "
#~ "before\n"
#~ "    \t\tattempting to read\n"
#~ "      -r\tdo not allow backslashes to escape any characters\n"
#~ "      -s\tdo not echo input coming from a terminal\n"
#~ "      -t timeout\ttime out and return failure if a complete line of\n"
#~ "    \t\tinput is not read within TIMEOUT seconds.  The value of the\n"
#~ "    \t\tTMOUT variable is the default timeout.  TIMEOUT may be a\n"
#~ "    \t\tfractional number.  If TIMEOUT is 0, read returns\n"
#~ "    \t\timmediately, without trying to read any data, returning\n"
#~ "    \t\tsuccess only if input is available on the specified\n"
#~ "    \t\tfile descriptor.  The exit status is greater than 128\n"
#~ "    \t\tif the timeout is exceeded\n"
#~ "      -u fd\tread from file descriptor FD instead of the standard input\n"
#~ "    \n"
#~ "    Exit Status:\n"
#~ "    The return code is zero, unless end-of-file is encountered, read "
#~ "times out\n"
#~ "    (in which case it's greater than 128), a variable assignment error "
#~ "occurs,\n"
#~ "    or an invalid file descriptor is supplied as the argument to -u."
#~ msgstr ""
#~ "Liest eine Zeile von der Standardeingabe und teilt sie in Felder auf.\n"
#~ "    \n"
#~ "    Liest eine einzelne Zeile aus der Standardeingabe oder vom\n"
#~ "    Dateideskriptor FD wenn die Option -u angegeben ist.  Die Zeile\n"
#~ "    wird wie bei der Wortaufteilung in Felder aufgeteilt aufgeteilt,\n"
#~ "    und das erste Wort wird dem ersten NAME zugewiesen, das zweite\n"
#~ "    NAME zugewiesen, das zweite Wort dem zweiten NAME usw., wobei alle\n"
#~ "    verbleibenden Wörter dem dem letzten NAME zugeordnet werden. Die\n"
#~ "    in $IFS enthaltenen Zeichen werden als Worttrennzeichen verwendet.\n"
#~ "    \n"
#~ "    Wenn keine NAMEn angegeben werden, wird die gelesene Zeile in der\n"
#~ "    REPLY-Variablen gespeichert.\n"
#~ "    \n"
#~ "    Optionen:\n"
#~ "      -a array weist die gelesenen Wörter den aufeinanderfolgenden\n"
#~ "               Indizes der Array Variable ARRAY, beginnend bei Null.\n"
#~ "      -d delim fortfahren, bis das erste Zeichen von DELIM gelesen\n"
#~ "               wird, anstelle von statt Newline.\n"
#~ "      -e Readline verwenden, um die Zeile zu lesen.\n"
#~ "      -i text TEXT als Anfangstext für Readline verwenden.\n"
#~ "      -n nchars Liest maximal NCHARS Zeichen, ohne ein Zeilenumbruch\n"
#~ "    \t\tzu suchen. Worttrennzeichen werden ausgewertet.\n"
#~ "      -N nchars Liest genau NCHARS Zeichen, bis EOF oder einer\n"
#~ "    \t\tZeitüberschreitung. Worttrennzeichen werden ignoriert.\n"
#~ "      -p prompt Gibt vor dem Lesen die Zeichenkette PROMPT ohne einen\n"
#~ "    \t\tabschließenden Zeilenumbruch aus.\n"
#~ "      -r        lässt keine Backslashes als Escape-Zeichen zu\n"
#~ "      -s        keine Echo-Eingabe von einem Terminal\n"
#~ "      -t timeout\n"
#~ "                Zeitüberschreitung und Rückgabe eines Fehlers, wenn\n"
#~ "    \t\teine vollständige Eingabezeile nicht innerhalb von\n"
#~ "    \t\tTIMEOUT Sekunden gelesen wird. Die TMOUT Variable\n"
#~ "    \t\tenthält das Standard-Timeout.  TIMEOUT kann als\n"
#~ "    \t\tBruchteil angegeben werden.  Wenn TIMEOUT gleich 0\n"
#~ "    \t\tist, werden keine daten geleden und gibt Erfolg\n"
#~ "    \t\tzurück, wenn Daten dem angegebenen Dateideskriptor\n"
#~ "    \t\tverfügbar sind.  Der Rückgabewert ist größer als 128,\n"
#~ "    \t\twenn die Zeitüberschreitung abgelaufen ist.\n"
#~ "      -u fd Lesen von Dateideskriptor FD statt von der Standardeingabe\n"
#~ "    \n"
#~ "    Rückgabewert: \n"
#~ "    Der Rückgabewert ist Null. Es sei denn, das Dateiende wurde\n"
#~ "    erreicht, die Lesezeit überschritten (in diesem Fall ist er größer\n"
#~ "    als 128), ein Variablenzuweisungsfehler tritt auf oder ein\n"
#~ "    ungültiger Dateideskriptor wurde als Argument von -u übergeben."

#~ msgid ""
#~ "Return from a shell function.\n"
#~ "    \n"
#~ "    Causes a function or sourced script to exit with the return value\n"
#~ "    specified by N.  If N is omitted, the return status is that of the\n"
#~ "    last command executed within the function or script.\n"
#~ "    \n"
#~ "    Exit Status:\n"
#~ "    Returns N, or failure if the shell is not executing a function or "
#~ "script."
#~ msgstr ""
#~ "Rückkehr aus einer Shell-Funktion.\n"
#~ "    \n"
#~ "    Bewirkt, dass eine Funktion oder ein geladenes Skript mit dem\n"
#~ "    durch N angegebenen Rückgabewert beendet wird.  Wenn N weggelassen\n"
#~ "    wird, wird als Rückgabewert der des zuletzt ausgeführten Befehls\n"
#~ "    verwendet.\n"
#~ "    \n"
#~ "    Rückgabewert:\n"
#~ "    Gibt N zurück, oder einen Fehler, wenn return außerhalb einer "
#~ "Funktion\n"
#~ "    oder Skript aufgerufen wird."

# set
#~ msgid ""
#~ "Set or unset values of shell options and positional parameters.\n"
#~ "    \n"
#~ "    Change the value of shell attributes and positional parameters, or\n"
#~ "    display the names and values of shell variables.\n"
#~ "    \n"
#~ "    Options:\n"
#~ "      -a  Mark variables which are modified or created for export.\n"
#~ "      -b  Notify of job termination immediately.\n"
#~ "      -e  Exit immediately if a command exits with a non-zero status.\n"
#~ "      -f  Disable file name generation (globbing).\n"
#~ "      -h  Remember the location of commands as they are looked up.\n"
#~ "      -k  All assignment arguments are placed in the environment for a\n"
#~ "          command, not just those that precede the command name.\n"
#~ "      -m  Job control is enabled.\n"
#~ "      -n  Read commands but do not execute them.\n"
#~ "      -o option-name\n"
#~ "          Set the variable corresponding to option-name:\n"
#~ "              allexport    same as -a\n"
#~ "              braceexpand  same as -B\n"
#~ "              emacs        use an emacs-style line editing interface\n"
#~ "              errexit      same as -e\n"
#~ "              errtrace     same as -E\n"
#~ "              functrace    same as -T\n"
#~ "              hashall      same as -h\n"
#~ "              histexpand   same as -H\n"
#~ "              history      enable command history\n"
#~ "              ignoreeof    the shell will not exit upon reading EOF\n"
#~ "              interactive-comments\n"
#~ "                           allow comments to appear in interactive "
#~ "commands\n"
#~ "              keyword      same as -k\n"
#~ "              monitor      same as -m\n"
#~ "              noclobber    same as -C\n"
#~ "              noexec       same as -n\n"
#~ "              noglob       same as -f\n"
#~ "              nolog        currently accepted but ignored\n"
#~ "              notify       same as -b\n"
#~ "              nounset      same as -u\n"
#~ "              onecmd       same as -t\n"
#~ "              physical     same as -P\n"
#~ "              pipefail     the return value of a pipeline is the status "
#~ "of\n"
#~ "                           the last command to exit with a non-zero "
#~ "status,\n"
#~ "                           or zero if no command exited with a non-zero "
#~ "status\n"
#~ "              posix        change the behavior of bash where the default\n"
#~ "                           operation differs from the Posix standard to\n"
#~ "                           match the standard\n"
#~ "              privileged   same as -p\n"
#~ "              verbose      same as -v\n"
#~ "              vi           use a vi-style line editing interface\n"
#~ "              xtrace       same as -x\n"
#~ "      -p  Turned on whenever the real and effective user ids do not "
#~ "match.\n"
#~ "          Disables processing of the $ENV file and importing of shell\n"
#~ "          functions.  Turning this option off causes the effective uid "
#~ "and\n"
#~ "          gid to be set to the real uid and gid.\n"
#~ "      -t  Exit after reading and executing one command.\n"
#~ "      -u  Treat unset variables as an error when substituting.\n"
#~ "      -v  Print shell input lines as they are read.\n"
#~ "      -x  Print commands and their arguments as they are executed.\n"
#~ "      -B  the shell will perform brace expansion\n"
#~ "      -C  If set, disallow existing regular files to be overwritten\n"
#~ "          by redirection of output.\n"
#~ "      -E  If set, the ERR trap is inherited by shell functions.\n"
#~ "      -H  Enable ! style history substitution.  This flag is on\n"
#~ "          by default when the shell is interactive.\n"
#~ "      -P  If set, do not resolve symbolic links when executing commands\n"
#~ "          such as cd which change the current directory.\n"
#~ "      -T  If set, the DEBUG and RETURN traps are inherited by shell "
#~ "functions.\n"
#~ "      --  Assign any remaining arguments to the positional parameters.\n"
#~ "          If there are no remaining arguments, the positional parameters\n"
#~ "          are unset.\n"
#~ "      -   Assign any remaining arguments to the positional parameters.\n"
#~ "          The -x and -v options are turned off.\n"
#~ "    \n"
#~ "    Using + rather than - causes these flags to be turned off.  The\n"
#~ "    flags can also be used upon invocation of the shell.  The current\n"
#~ "    set of flags may be found in $-.  The remaining n ARGs are "
#~ "positional\n"
#~ "    parameters and are assigned, in order, to $1, $2, .. $n.  If no\n"
#~ "    ARGs are given, all shell variables are printed.\n"
#~ "    \n"
#~ "    Exit Status:\n"
#~ "    Returns success unless an invalid option is given."
#~ msgstr ""
#~ "Setzen oder Aufheben von Shell-Optionen und Positionsparametern.\n"
#~ "    \n"
#~ "    Den Wert von Shell-Attributen und Positionsparametern ändern, oder\n"
#~ "    die Namen und Werte von Shell-Variablen anzeigen.\n"
#~ "    \n"
#~ "    Optionen:\n"
#~ "      -a Markieren von Variablen die geändert oder erstellt wurden, für "
#~ "den Export.\n"
#~ "      -b Sofortige Benachrichtigung über das Auftragsende.\n"
#~ "      -e Sofortiger Abbruch, wenn ein Befehl mit einem Status ungleich "
#~ "Null beendet wird.\n"
#~ "      -f Deaktiviert das Generieren von Dateinamen (globbing).\n"
#~ "      -h Merkt sich den Speicherort von Befehlen, wenn sie nachgeschlagen "
#~ "werden.\n"
#~ "      -k Alle Zuweisungsargumente werden in die Umgebung für einen\n"
#~ "         Befehl in die Umgebung aufgenommen, nicht nur diejenigen,\n"
#~ "         die dem Befehl vorangestellt sind.\n"
#~ "      -m Die Auftragskontrolle ist aktiviert.\n"
#~ "      -n Befehle lesen, aber nicht ausführen.\n"
#~ "      -o Optionsname\n"
#~ "          Setzt die Variable, die dem Optionsname entspricht:\n"
#~ "              allexport wie -a\n"
#~ "              braceexpand wie -B\n"
#~ "              emacs verwendet eine emacsähnliche Schnittstelle zur "
#~ "Zeilenbearbeitung\n"
#~ "              errexit gleich wie -e\n"
#~ "              errtrace dasselbe wie -E\n"
#~ "              functrace dasselbe wie -T\n"
#~ "              hashall dasselbe wie -h\n"
#~ "              histexpand gleich wie -H\n"
#~ "              history Befehlshistorie aktivieren\n"
#~ "              ignoreeof die Shell wird beim Lesen von EOF nicht beendet\n"
#~ "              interaktive-Kommentare\n"
#~ "                           erlaubt das Erscheinen von Kommentaren in "
#~ "interaktiven Befehlen\n"
#~ "              keyword dasselbe wie -k\n"
#~ "              monitor gleich wie -m\n"
#~ "              noclobber dasselbe wie -C\n"
#~ "              noexec gleich wie -n\n"
#~ "              noglob gleich wie -f\n"
#~ "              nolog wird derzeit akzeptiert, aber ignoriert\n"
#~ "              notify gleich wie -b\n"
#~ "              nounset dasselbe wie -u\n"
#~ "              onecmd dasselbe wie -t\n"
#~ "              physical wie -P\n"
#~ "              pipefail der Rückgabewert einer Pipeline ist der Status\n"
#~ "                       des des letzten Befehls, der mit einem Status\n"
#~ "                       ungleich Null beendet wurde, oder Null, wenn\n"
#~ "                       kein Befehl mit einem Status ungleich Null\n"
#~ "                       beendet wurde.\n"
#~ "             posix     Ändert das Verhalten von bash, wo die Standard\n"
#~ "                       Operation vom Posix-Standard abweicht, um mit\n"
#~ "                       dem Standard übereinstimmen.\n"
#~ "              privilegiert gleich wie -p\n"
#~ "              verbose dasselbe wie -v\n"
#~ "              vi eine vi-ähnliche Schnittstelle zur Zeilenbearbeitung "
#~ "verwenden\n"
#~ "              xtrace dasselbe wie -x\n"
#~ "      -p Wird eingeschaltet, wenn die realen und effektiven\n"
#~ "         Benutzerkennungen nicht übereinstimmen.  Deaktiviert die\n"
#~ "         Verarbeitung der $ENV-Datei und das Importieren von Shell\n"
#~ "         Funktionen.  Wenn diese Option ausgeschalten ist, werden die\n"
#~ "         effektive uid und gid auf die reale uid und gid gesetzt. \n"
#~ "      -t Beenden nach dem Lesen und Ausführen eines Befehls.\n"
#~ "      -u Nicht gesetzte Variablen beim Substituieren als Fehler "
#~ "behandeln.\n"
#~ "      -v Shell-Eingabezeilen ausgeben, wenn sie gelesen werden.\n"
#~ "      -x Befehle und ihre Argumente ausgeben, wenn sie ausgeführt "
#~ "werden.\n"
#~ "      -B Die Shell führt eine Klammererweiterung durch\n"
#~ "      -C Dateien werden bei Ausgabeumleitung nicht überschrieben.\n"
#~ "      -E Wenn gesetzt, wird die Fehlerfalle (trap) an Shell-Funktionen "
#~ "vererbt.\n"
#~ "      -H Aktiviert die !-Stil Verlaufsersetzung.  Diese Option ist\n"
#~ "         bei einer interaktiven Shell standardmäßig aktiviert.\n"
#~ "      -P Symbolische Links werden nicht aufgelöst, wenn Befehle wie\n"
#~ "         z.B. cd, das aktuelle Verzeichnis ändern.\n"
#~ "      -T DEBUG und RETURN Fallen (trap) werden an Shellfunktionen "
#~ "vererbt.\n"
#~ "      -- Weist alle verbleibenden Argumente den Positionsparametern\n"
#~ "         zu.  Sind keine Argumente verblieben, werden die\n"
#~ "         Positionsparameter nicht gesetzt.\n"
#~ "      - Weist alle verbleibenden Argumente den Positionsparametern zu.\n"
#~ "        Die Optionen -x und -v sind ausgeschaltet.\n"
#~ "    \n"
#~ "    Durch Verwenden von + anstelle von - werden Option ausgeschaltet.\n"
#~ "    Die Optionen können auch beim Shellaufruf verwendet werden.  Die\n"
#~ "    aktuelle aktiven Optionen sind in $- gespeichert.  Die restlichen\n"
#~ "    n ARGs sind positionale Parameter und werden der Reihe nach $1,\n"
#~ "    $2, ... $n zugewiesen.  Wenn keine ARGs angegeben werden, werden\n"
#~ "    alle Shell-Variablen ausgegeben.\n"
#~ "    \n"
#~ "    Rückgabewert:\n"
#~ "    Gibt Erfolg zurück, es sei denn, eine ungültige Option wurde "
#~ "angegeben."

# [
#~ msgid ""
#~ "Evaluate conditional expression.\n"
#~ "    \n"
#~ "    This is a synonym for the \"test\" builtin, but the last argument "
#~ "must\n"
#~ "    be a literal `]', to match the opening `['."
#~ msgstr ""
#~ "Wertet einen bedingten Ausdruck aus.\n"
#~ "\n"
#~ "    Dieses Kommando entspricht dem Kommando »test«. Jedoch muss das\n"
#~ "    letzte Argument ein »]« sein, welches die öffnende Klammer »[«\n"
#~ "    schließt."

# times
#~ msgid ""
#~ "Display process times.\n"
#~ "    \n"
#~ "    Prints the accumulated user and system times for the shell and all of "
#~ "its\n"
#~ "    child processes.\n"
#~ "    \n"
#~ "    Exit Status:\n"
#~ "    Always succeeds."
#~ msgstr ""
#~ "Zeigt den Zeitverbrauch an.\n"
#~ "\n"
#~ "    Gibt den kumulierte Nutzer- und Systemzeitverbrauch der Shell und\n"
#~ "    aller von ihr gestarteten Prozesse aus.\n"
#~ "\n"
#~ "    Rückgabewert:\n"
#~ "    Immer 0."

# (( ))
#~ msgid ""
#~ "Evaluate arithmetic expression.\n"
#~ "    \n"
#~ "    The EXPRESSION is evaluated according to the rules for arithmetic\n"
#~ "    evaluation.  Equivalent to `let \"EXPRESSION\"'.\n"
#~ "    \n"
#~ "    Exit Status:\n"
#~ "    Returns 1 if EXPRESSION evaluates to 0; returns 0 otherwise."
#~ msgstr ""
#~ "Wertet arithmetische Ausdrücke aus.\n"
#~ "\n"
#~ "    Der Ausdruck wird nach den Regeln für arithmetische Berechnungen\n"
#~ "    ausgewertet. Diese Schreibweise entspricht »let Ausdruck«.\n"
#~ "\n"
#~ "    Rückgabewert:\n"
#~ "    Ist »1«, wenn der arithmetische Ausdruck 0 ergibt, sonst »0«."

# [[
#~ msgid ""
#~ "Execute conditional command.\n"
#~ "    \n"
#~ "    Returns a status of 0 or 1 depending on the evaluation of the "
#~ "conditional\n"
#~ "    expression EXPRESSION.  Expressions are composed of the same "
#~ "primaries used\n"
#~ "    by the `test' builtin, and may be combined using the following "
#~ "operators:\n"
#~ "    \n"
#~ "      ( EXPRESSION )\tReturns the value of EXPRESSION\n"
#~ "      ! EXPRESSION\t\tTrue if EXPRESSION is false; else false\n"
#~ "      EXPR1 && EXPR2\tTrue if both EXPR1 and EXPR2 are true; else false\n"
#~ "      EXPR1 || EXPR2\tTrue if either EXPR1 or EXPR2 is true; else false\n"
#~ "    \n"
#~ "    When the `==' and `!=' operators are used, the string to the right "
#~ "of\n"
#~ "    the operator is used as a pattern and pattern matching is performed.\n"
#~ "    When the `=~' operator is used, the string to the right of the "
#~ "operator\n"
#~ "    is matched as a regular expression.\n"
#~ "    \n"
#~ "    The && and || operators do not evaluate EXPR2 if EXPR1 is sufficient "
#~ "to\n"
#~ "    determine the expression's value.\n"
#~ "    \n"
#~ "    Exit Status:\n"
#~ "    0 or 1 depending on value of EXPRESSION."
#~ msgstr ""
#~ "Erweiterte Vergleiche.\n"
#~ "    \n"
#~ "    Der Status 0 oder 1 wird abhängig vom Vergleichsergebnis "
#~ "zurückgegeben.\n"
#~ "    Es werden die gleichen Ausdrücke wie in der »test« Funktion "
#~ "unterstützt,\n"
#~ "    die mit folgenden Operatoren verbunden werden können:\n"
#~ "    \n"
#~ "      ( AUSDRUCK )\tErgibt den Wert des AUSDRUCKs\n"
#~ "      ! Ausdruck\t\tNegiert den AUSDRUCK\n"
#~ "      AUSDR1 && AUSDR2\tUnd Verknüpfung der Ausdrücke\n"
#~ "      AUSDR1 || AUSDR2\tOder Verknüpfung der Ausdrücke\n"
#~ "    \n"
#~ "    Die `==' und `!=' Operatoren ermöglichen einen Mustervergleich mit "
#~ "dem\n"
#~ "    rechten Ausdruck als Muster.\n"
#~ "    Der `=~' Operator führt einen Vergleich mit dem regulären Ausdruck\n"
#~ "    in der rechten Seite aus.\n"
#~ "    \n"
#~ "    Die && und || Operatoren werten AUSDR2 nur aus, wenn nicht bereits\n"
#~ "    AUSDR1 das gesamte Ergebnis bestimt.\n"
#~ "    \n"
#~ "    Rückgabewert:\n"
#~ "    0 oder 1 abhängig vom Wert des AUSDRUCKs."

# variable_help
#~ msgid ""
#~ "Common shell variable names and usage.\n"
#~ "    \n"
#~ "    BASH_VERSION\tVersion information for this Bash.\n"
#~ "    CDPATH\tA colon-separated list of directories to search\n"
#~ "    \t\tfor directories given as arguments to `cd'.\n"
#~ "    GLOBIGNORE\tA colon-separated list of patterns describing filenames "
#~ "to\n"
#~ "    \t\tbe ignored by pathname expansion.\n"
#~ "    HISTFILE\tThe name of the file where your command history is stored.\n"
#~ "    HISTFILESIZE\tThe maximum number of lines this file can contain.\n"
#~ "    HISTSIZE\tThe maximum number of history lines that a running\n"
#~ "    \t\tshell can access.\n"
#~ "    HOME\tThe complete pathname to your login directory.\n"
#~ "    HOSTNAME\tThe name of the current host.\n"
#~ "    HOSTTYPE\tThe type of CPU this version of Bash is running under.\n"
#~ "    IGNOREEOF\tControls the action of the shell on receipt of an EOF\n"
#~ "    \t\tcharacter as the sole input.  If set, then the value\n"
#~ "    \t\tof it is the number of EOF characters that can be seen\n"
#~ "    \t\tin a row on an empty line before the shell will exit\n"
#~ "    \t\t(default 10).  When unset, EOF signifies the end of input.\n"
#~ "    MACHTYPE\tA string describing the current system Bash is running on.\n"
#~ "    MAILCHECK\tHow often, in seconds, Bash checks for new mail.\n"
#~ "    MAILPATH\tA colon-separated list of filenames which Bash checks\n"
#~ "    \t\tfor new mail.\n"
#~ "    OSTYPE\tThe version of Unix this version of Bash is running on.\n"
#~ "    PATH\tA colon-separated list of directories to search when\n"
#~ "    \t\tlooking for commands.\n"
#~ "    PROMPT_COMMAND\tA command to be executed before the printing of each\n"
#~ "    \t\tprimary prompt.\n"
#~ "    PS1\t\tThe primary prompt string.\n"
#~ "    PS2\t\tThe secondary prompt string.\n"
#~ "    PWD\t\tThe full pathname of the current directory.\n"
#~ "    SHELLOPTS\tA colon-separated list of enabled shell options.\n"
#~ "    TERM\tThe name of the current terminal type.\n"
#~ "    TIMEFORMAT\tThe output format for timing statistics displayed by the\n"
#~ "    \t\t`time' reserved word.\n"
#~ "    auto_resume\tNon-null means a command word appearing on a line by\n"
#~ "    \t\titself is first looked for in the list of currently\n"
#~ "    \t\tstopped jobs.  If found there, that job is foregrounded.\n"
#~ "    \t\tA value of `exact' means that the command word must\n"
#~ "    \t\texactly match a command in the list of stopped jobs.  A\n"
#~ "    \t\tvalue of `substring' means that the command word must\n"
#~ "    \t\tmatch a substring of the job.  Any other value means that\n"
#~ "    \t\tthe command must be a prefix of a stopped job.\n"
#~ "    histchars\tCharacters controlling history expansion and quick\n"
#~ "    \t\tsubstitution.  The first character is the history\n"
#~ "    \t\tsubstitution character, usually `!'.  The second is\n"
#~ "    \t\tthe `quick substitution' character, usually `^'.  The\n"
#~ "    \t\tthird is the `history comment' character, usually `#'.\n"
#~ "    HISTIGNORE\tA colon-separated list of patterns used to decide which\n"
#~ "    \t\tcommands should be saved on the history list.\n"
#~ msgstr ""
#~ "    BASH_VERSION\tVersionsnummer der Bash.\n"
#~ "    CDPATH\tEine durch Doppelpunkte getrennte Liste von\n"
#~ "                Verzeichnissen, die durchsucht werden, wenn das\n"
#~ "                Argument von »cd« nicht im aktuellen Verzeichnis\n"
#~ "                gefunden wird.\n"
#~ "    GLOBIGNORE  Eine durch Doppelpunkte getrennte Liste von\n"
#~ "                Dateinamenmustern, die für die Dateinamensergänzung\n"
#~ "                ignoriert werden.\n"
#~ "    HISTFILE\tDatei, die den Kommandozeilenspeicher enthält.\n"
#~ "    HISTFILESIZE\tMaximale Zeilenanzahl dieser Datei.\n"
#~ "    HISTSIZE\tMaximale Anzahl von Zeilen, auf die der\n"
#~ "                Historymechanismus der Shell zurückgreifen kann.\n"
#~ "    HOME\tHeimatverzeichnis des aktuellen Benutzers.\n"
#~ "    HOSTNAME    Der aktuelle Rechnername.\n"
#~ "    HOSTTYPE\tCPU-Typ des aktuellen Rechners.\n"
#~ "    IGNOREEOF\tLegt die Reaktion der Shell auf ein EOF-Zeichen fest.\n"
#~ "                Wenn die Variable eine ganze Zahl enthält, wird diese\n"
#~ "                Anzahl EOF Zeichen (Ctrl-D) abgewartet, bis die Shell\n"
#~ "                verlassen wird. Der Vorgabewert ist 10. Ist IGNOREEOF\n"
#~ "                nicht gesetzt, signalisiert EOF das Ende der Eingabe.\n"
#~ "    MACHTYPE    Eine Zeichenkette die das aktuell laufende System "
#~ "beschreibt.\n"
#~ "    MAILCHECK\tZeit in Sekunden, nach der nach E-Mails gesehen wird.\n"
#~ "    MAILPATH\tEine durch Doppelpunkt getrennte Liste von Dateinamen,\n"
#~ "                die nach E-Mail durchsucht werden.\n"
#~ "    OSTYPE\tUnix Version, auf der die Bash gegenwärtig läuft.\n"
#~ "    PATH\tDurch Doppelpunkt getrennte Liste von Verzeichnissen,\n"
#~ "                die nach Kommandos durchsucht werden.\n"
#~ "    PROMPT_COMMAND\tKommando, das vor der Anzeige einer primären\n"
#~ "                        Eingabeaufforderung (PS1) ausgeführt wird.\n"
#~ "    PS1                 Zeichenkette, die die primäre\n"
#~ "                        Eingabeaufforderung enthält.\n"
#~ "    PS2                 Zeichenkette, die die sekundäre\n"
#~ "                        Eingabeaufforderung enthält.\n"
#~ "    PWD                 Der vollständige aktuelle Verzeichnisname.\n"
#~ "    SHELLOPTS           Durch Doppelpunkt getrennte Liste der aktiven\n"
#~ "                        Shell-Optionen.\n"
#~ "    TERM\tName des aktuellen Terminaltyps.\n"
#~ "    auto_resume Ein Wert ungleich Null bewirkt, dass ein einzelnes\n"
#~ "                Kommando auf einer Zeile zunächst in der Liste\n"
#~ "                gegenwärtig gestoppter Jobs gesucht und dieser in den\n"
#~ "                Vordergrund geholt wird. »exact« bewirkt, dass das\n"
#~ "                Kommando genau dem Kommando in der Liste der\n"
#~ "                gestoppten Jobs entsprechen muss. Wenn die Variable den\n"
#~ "                Wert »substring« enthält, muss das Kommando einem\n"
#~ "                Substring der Jobbezeichnung entsprechen. Bei einem\n"
#~ "                anderen Wert müssen die ersten Zeichen übereinstimmen.\n"
#~ "    histchars   Zeichen, die die Befehlswiederholung und die\n"
#~ "                Schnellersetzung steuern. An erster Stelle steht\n"
#~ "                das Befehlswiederholungszeichen (normalerweise\n"
#~ "                `!'); an zweiter das `Schnell-Ersetzen-Zeichen'\n"
#~ "                (normalerweise `^'). Das dritte Zeichen ist das\n"
#~ "                `Kommentarzeichen' (normalerweise `#').\n"
#~ "    HISTIGNORE  Eine durch Doppelpunkt getrennte Liste von\n"
#~ "                Mustern, welche die in der\n"
#~ "                Befehlswiederholungsliste zu speichernden\n"
#~ "                Kommandos angibt.\n"

# pushd
#~ msgid ""
#~ "Add directories to stack.\n"
#~ "    \n"
#~ "    Adds a directory to the top of the directory stack, or rotates\n"
#~ "    the stack, making the new top of the stack the current working\n"
#~ "    directory.  With no arguments, exchanges the top two directories.\n"
#~ "    \n"
#~ "    Options:\n"
#~ "      -n\tSuppresses the normal change of directory when adding\n"
#~ "    \t\tdirectories to the stack, so only the stack is manipulated.\n"
#~ "    \n"
#~ "    Arguments:\n"
#~ "      +N\tRotates the stack so that the Nth directory (counting\n"
#~ "    \t\tfrom the left of the list shown by `dirs', starting with\n"
#~ "    \t\tzero) is at the top.\n"
#~ "    \n"
#~ "      -N\tRotates the stack so that the Nth directory (counting\n"
#~ "    \t\tfrom the right of the list shown by `dirs', starting with\n"
#~ "    \t\tzero) is at the top.\n"
#~ "    \n"
#~ "      dir\tAdds DIR to the directory stack at the top, making it the\n"
#~ "    \t\tnew current working directory.\n"
#~ "    \n"
#~ "    The `dirs' builtin displays the directory stack.\n"
#~ "    \n"
#~ "    Exit Status:\n"
#~ "    Returns success unless an invalid argument is supplied or the "
#~ "directory\n"
#~ "    change fails."
#~ msgstr ""
#~ "Fügt ein Verzeichnis dem Stapel hinzu.\n"
#~ "\n"
#~ "    Legt einen Verzeichnisnamen auf den Verzeichnisstapel oder rotiert\n"
#~ "    diesen so, dass das aktuelle Arbeitsverzeichnis oben liegt. Ohne\n"
#~ "    Argumente werden die obersten zwei Verzeichnisse auf dem Stapel\n"
#~ "    vertauscht.\n"
#~ "\n"
#~ "    Optionen: -n Es wird nur das angebene Verzeichnis dem Stapel\n"
#~ "    \thinzugefügt, aber nicht in das Verzeichnis gewechselt.\n"
#~ "\n"
#~ "    Argumente:    \n"
#~ "    +N\tRotiert den Stapel so, dass das N'te Verzeichnis (angezeigt\n"
#~ "        von `dirs', gezählt von links) oben auf dem Stapels liegt.\n"
#~ "\n"
#~ "    -N\tRotiert den Stapel so, dass das N'te Verzeichnis (angezeigt\n"
#~ "        von `dirs', gezählt von rechts) sich an der Spitze des Stapels\n"
#~ "    \tbefindet.\n"
#~ "\n"
#~ "    Der Verzeichnisstapel kann mit dem Kommando `dirs' angezeigt\n"
#~ "    werden.\n"
#~ "\n"
#~ "    Rückgabewert: \n"
#~ "    Gibt Erfolg zurück, außer wenn ein ungültiges Argument angegeben\n"
#~ "    wurde oder der Verzeichniswechsel nicht erfolgreich war."

# popd
#~ msgid ""
#~ "Remove directories from stack.\n"
#~ "    \n"
#~ "    Removes entries from the directory stack.  With no arguments, "
#~ "removes\n"
#~ "    the top directory from the stack, and changes to the new top "
#~ "directory.\n"
#~ "    \n"
#~ "    Options:\n"
#~ "      -n\tSuppresses the normal change of directory when removing\n"
#~ "    \t\tdirectories from the stack, so only the stack is manipulated.\n"
#~ "    \n"
#~ "    Arguments:\n"
#~ "      +N\tRemoves the Nth entry counting from the left of the list\n"
#~ "    \t\tshown by `dirs', starting with zero.  For example: `popd +0'\n"
#~ "    \t\tremoves the first directory, `popd +1' the second.\n"
#~ "    \n"
#~ "      -N\tRemoves the Nth entry counting from the right of the list\n"
#~ "    \t\tshown by `dirs', starting with zero.  For example: `popd -0'\n"
#~ "    \t\tremoves the last directory, `popd -1' the next to last.\n"
#~ "    \n"
#~ "    The `dirs' builtin displays the directory stack.\n"
#~ "    \n"
#~ "    Exit Status:\n"
#~ "    Returns success unless an invalid argument is supplied or the "
#~ "directory\n"
#~ "    change fails."
#~ msgstr ""
#~ "Entfernt Einträge vom Verzeichnisstapel.\n"
#~ "\n"
#~ "    Entfernt Einträge vom Verzeichnisstapel. Ohne Argumente wird der\n"
#~ "    oberste Eintrag entfernt und in das neue oberste Verzeichnis\n"
#~ "    gewechselt.\n"
#~ "\n"
#~ "    Optionen:\n"
#~ "    -n\tEntfernt nur den Verzeichniseintrag und wechselt nicht\n"
#~ "       \tdas Verzeichnis.\n"
#~ "          \n"
#~ "    Argumente:\n"
#~ "    +N\tEntfernt den N-ten Eintrag von links, gezählt von\n"
#~ "        Null, aus der von »dirs« anzeigten Liste. Beispielsweise\n"
#~ "        entfernen »popd +0« den ersten und »popd +1« den zweiten\n"
#~ "        Verzeichniseintrag.\n"
#~ "\n"
#~ "    -N\tEntfernt den N-ten Eintrag von rechts, gezählt von Null,\n"
#~ "      \taus der von »dirs« angeigten Liste. Beispielsweise entfernen\n"
#~ "        »popd -0« den letzten und »popd -1« den vorletzten\n"
#~ "        Verzeichniseintrag.\n"
#~ "\n"
#~ "        Mit »dirs« kann der Verzeichnisstapel angezeigt werden.\n"
#~ "\n"
#~ "        Rückgabewert:\n"
#~ "        Gibt 0 zurück, außer wenn ein ungültiges Argument angegeben\n"
#~ "        wurde oder der Verzeichniswechsel nicht erfolgreich war."

# dirs
#~ msgid ""
#~ "Display directory stack.\n"
#~ "    \n"
#~ "    Display the list of currently remembered directories.  Directories\n"
#~ "    find their way onto the list with the `pushd' command; you can get\n"
#~ "    back up through the list with the `popd' command.\n"
#~ "    \n"
#~ "    Options:\n"
#~ "      -c\tclear the directory stack by deleting all of the elements\n"
#~ "      -l\tdo not print tilde-prefixed versions of directories relative\n"
#~ "    \t\tto your home directory\n"
#~ "      -p\tprint the directory stack with one entry per line\n"
#~ "      -v\tprint the directory stack with one entry per line prefixed\n"
#~ "    \t\twith its position in the stack\n"
#~ "    \n"
#~ "    Arguments:\n"
#~ "      +N\tDisplays the Nth entry counting from the left of the list\n"
#~ "    \t\tshown by dirs when invoked without options, starting with\n"
#~ "    \t\tzero.\n"
#~ "    \n"
#~ "      -N\tDisplays the Nth entry counting from the right of the list\n"
#~ "    \t\tshown by dirs when invoked without options, starting with\n"
#~ "    \t\tzero.\n"
#~ "    \n"
#~ "    Exit Status:\n"
#~ "    Returns success unless an invalid option is supplied or an error "
#~ "occurs."
#~ msgstr ""
#~ "Zeigt den Verzeichnisstapel an.\n"
#~ "\n"
#~ "    Zeigt die Liste der gegenwärtig gespeicherten Verzeichnisse.\n"
#~ "    Diese werden mit dem `pushd' Kommando eingetragen und mit dem\n"
#~ "    `popd' Kommando ausgelesen.\n"
#~ "\n"
#~ "    Optionen:\n"
#~ "      -c        Löscht den Verzeichnisstapel.\n"
#~ "      -l        Keine Abkürzung für das Heimatverzeichnis durch die\n"
#~ "                Tilde (~).\n"
#~ "      -p        Ausgabe von einem Eintrag pro Zeile.\n"
#~ "      -v        Ausgabe von einem Eintrag pro Zeile mit Angabe der\n"
#~ "                Position im Stapel<\n"
#~ "\n"
#~ "    Argumente:\n"
#~ "      +N        Gibt das N'te Element von links der Liste aus, die\n"
#~ "                ohne Argumente ausgegeben wird.  Die Zählung beginnt\n"
#~ "                bei 0.\n"
#~ "      -N        Gibt das N'te Element von rechts der Liste aus, die\n"
#~ "                ohne Argumente ausgegeben wird.  Die Zählung beginnt\n"
#~ "                bei 0.\n"
#~ "\n"
#~ "    Rückgabewert:\n"
#~ "    Gibt Erfolg zurück, außer bei einer ungültigen Option oder wenn\n"
#~ "    ein Fehler auftritt."

#~ msgid ""
#~ "Set and unset shell options.\n"
#~ "    \n"
#~ "    Change the setting of each shell option OPTNAME.  Without any option\n"
#~ "    arguments, list each supplied OPTNAME, or all shell options if no\n"
#~ "    OPTNAMEs are given, with an indication of whether or not each is "
#~ "set.\n"
#~ "    \n"
#~ "    Options:\n"
#~ "      -o\trestrict OPTNAMEs to those defined for use with `set -o'\n"
#~ "      -p\tprint each shell option with an indication of its status\n"
#~ "      -q\tsuppress output\n"
#~ "      -s\tenable (set) each OPTNAME\n"
#~ "      -u\tdisable (unset) each OPTNAME\n"
#~ "    \n"
#~ "    Exit Status:\n"
#~ "    Returns success if OPTNAME is enabled; fails if an invalid option is\n"
#~ "    given or OPTNAME is disabled."
#~ msgstr ""
#~ "Setzt oder löscht Shell-Optionen.\n"
#~ "\n"
#~ "    Ändert die in »Optionsnamen« genannten Shell-Optionen. Ohne\n"
#~ "    Argumente wird eine Liste der Shell-Optionen und deren Status\n"
#~ "    ausgegeben.\n"
#~ "\n"
#~ "    Optionen:\n"
#~ "      -o        Beschränkt die Optionsmanen auf die, welche mit \n"
#~ "                »set -o« definiert werden müssen.\n"
#~ "      -p        Gibt alle Shelloptionen und deren Status aus.\n"
#~ "      -q        Unterdrückt Ausgaben.\n"
#~ "      -s        Setzt jede Option in »Optionsname.«\n"
#~ "      -u        Deaktiviert jede Option in »Optionsname«.\n"
#~ "\n"
#~ "    Rückgabewert:\n"
#~ "    Gibt Erfolg zurück, wenn eine Option gesetzt worden ist. Wenn\n"
#~ "    eine ungültige Option angegeben wurde oder eine Option deaktiviert\n"
#~ "    worden ist, wird ein Fehler zurückgegeben."

# printf
#, fuzzy
#~ msgid ""
#~ "Formats and prints ARGUMENTS under control of the FORMAT.\n"
#~ "    \n"
#~ "    Options:\n"
#~ "      -v var\tassign the output to shell variable VAR rather than\n"
#~ "    \t\tdisplay it on the standard output\n"
#~ "    \n"
#~ "    FORMAT is a character string which contains three types of objects: "
#~ "plain\n"
#~ "    characters, which are simply copied to standard output; character "
#~ "escape\n"
#~ "    sequences, which are converted and copied to the standard output; "
#~ "and\n"
#~ "    format specifications, each of which causes printing of the next "
#~ "successive\n"
#~ "    argument.\n"
#~ "    \n"
#~ "    In addition to the standard format specifications described in "
#~ "printf(1),\n"
#~ "    printf interprets:\n"
#~ "    \n"
#~ "      %b\texpand backslash escape sequences in the corresponding "
#~ "argument\n"
#~ "      %q\tquote the argument in a way that can be reused as shell input\n"
#~ "      %Q\tlike %q, but apply any precision to the unquoted argument "
#~ "before\n"
#~ "    \t\tquoting\n"
#~ "      %(fmt)T\toutput the date-time string resulting from using FMT as a "
#~ "format\n"
#~ "    \t        string for strftime(3)\n"
#~ "    \n"
#~ "    The format is re-used as necessary to consume all of the arguments.  "
#~ "If\n"
#~ "    there are fewer arguments than the format requires,  extra format\n"
#~ "    specifications behave as if a zero value or null string, as "
#~ "appropriate,\n"
#~ "    had been supplied.\n"
#~ "    \n"
#~ "    Exit Status:\n"
#~ "    Returns success unless an invalid option is given or a write or "
#~ "assignment\n"
#~ "    error occurs."
#~ msgstr ""
#~ "Formatierte Ausgabe der ARGUMENTE.\n"
#~ "\n"
#~ "    Optionen:\n"
#~ "      -v var\tDie formatierte Ausgabe ver Variable var zuweisen statt\n"
#~ "        \tsie an die Standardausgebe zu senden.\n"
#~ "\n"
#~ "    Die FORMAT-Zeichenkette kann einfache Zeichen enthalten, die "
#~ "unverändert\n"
#~ "    an die Standardausgabe geschickt werden. Escape-Sequenzen werden "
#~ "umgewandelt\n"
#~ "    und an die Standardausgabe geschickt sowie Formatanweisungen, welche "
#~ "das \n"
#~ "    nachfolgende ARGUMENT auswerten und ausgeben.\n"
#~ "\n"
#~ "    Gegenüber der in printf(1) beschriebenen Standardverion werden "
#~ "zusätzliche\n"
#~ "    Formatanweisungen ausgewertet:\n"
#~ "\n"
#~ "      %b\tWertet Escape-Sequenzen des zugehörigen Arguments aus.\n"
#~ "      %q\tBettet das Argument so ein, dass es als Shelleingabe\n"
#~ "                verwendet werden kann.\n"
#~ "      %(fmt)T\tAusgabe der aus FMT entstehende Datum-Zeit Zeichenkette, "
#~ "dass\n"
#~ "                sie als Zeichenkette für strftime(3) verwendet werden "
#~ "kann.\n"
#~ "\n"
#~ "    Die Formatangabe wird wiederverwendet, bis alle Argumente "
#~ "ausgewertet\n"
#~ "    sind. Wenn weniger Argumente als Formatangaben vorhanden sind, werden "
#~ "für\n"
#~ "    die Argumente Nullwerte bzw. leere Zeichenketten eingesetzt.\n"
#~ "\n"
#~ "    Rücgabewert:\n"
#~ "    Gibt Erfolg zurück, außer es wird eine ungültige Option angegeben "
#~ "oder ein\n"
#~ "    Aus- bzw. Zuweisungsfehler auftritt."

# compgen
#~ msgid ""
#~ "Display possible completions depending on the options.\n"
#~ "    \n"
#~ "    Intended to be used from within a shell function generating possible\n"
#~ "    completions.  If the optional WORD argument is supplied, matches "
#~ "against\n"
#~ "    WORD are generated.\n"
#~ "    \n"
#~ "    Exit Status:\n"
#~ "    Returns success unless an invalid option is supplied or an error "
#~ "occurs."
#~ msgstr ""
#~ "Zeigt mögliche Komplettierungen.\n"
#~ "\n"
#~ "    Wird in Shellfunktionen benutzt, um mögliche Komplettierungen "
#~ "anzuzeigen.\n"
#~ "    Wenn das optionale Wort-Argument angegeben ist, werden "
#~ "Komplettierungen\n"
#~ "    für dieses Wort erzeugt.\n"
#~ "    \n"
#~ "    Rückgabewert:\n"
#~ "    Falsche Optionen oder Fehler führen zu Rückgabewerten ungleich Null."

# readarray
#~ msgid ""
#~ "Read lines from a file into an array variable.\n"
#~ "    \n"
#~ "    A synonym for `mapfile'."
#~ msgstr ""
#~ "Liest Zeilen einer Datei in eine Array-Variable.\n"
#~ "\n"
#~ "    Ist ein Synonym für »mapfile«."

# https://lists.gnu.org/archive/html/bug-bash/2019-09/msg00025.html
#~ msgid "Unknown Signal #"
#~ msgstr "Unbekannte Signalnummer"
